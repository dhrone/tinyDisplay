"""
State-Based Trigger System for Advanced Animation Control

This module provides a sophisticated trigger system that enables responsive
animation control based on complex state conditions, trigger chaining, and
performance-optimized evaluation for real-time animation systems.

Key Features:
1. Complex condition evaluation with logical operators
2. Trigger chaining and cascading effects
3. Performance-optimized trigger evaluation
4. State change detection and monitoring
5. Trigger priority and execution ordering
6. Comprehensive trigger analytics and debugging
"""

import time
import threading
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Optional, Any, Callable, Union, Tuple
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict, deque

from .tick_based import TickAnimationEngine, TickAnimationDefinition, TickAnimationState
from .coordination import CoordinationEngine, CoordinationPrimitive, CoordinationEvent
from .timeline import TickTimeline, CoordinationPlan


class TriggerPriority(Enum):
    """Priority levels for trigger execution."""
    CRITICAL = 0    # Highest priority
    HIGH = 1
    NORMAL = 2
    LOW = 3
    BACKGROUND = 4  # Lowest priority


class TriggerState(Enum):
    """States of trigger execution."""
    INACTIVE = "inactive"
    ACTIVE = "active"
    TRIGGERED = "triggered"
    COMPLETED = "completed"
    FAILED = "failed"


class LogicalOperator(Enum):
    """Logical operators for combining conditions."""
    AND = "and"
    OR = "or"
    NOT = "not"
    XOR = "xor"


@dataclass
class TriggerEvent:
    """Event generated by trigger system."""
    trigger_id: str
    event_type: str
    tick: int
    data: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.perf_counter)
    priority: TriggerPriority = TriggerPriority.NORMAL


@dataclass
class TriggerPerformanceMetrics:
    """Performance metrics for trigger system."""
    total_evaluations: int = 0
    total_triggers: int = 0
    average_evaluation_time: float = 0.0
    peak_evaluation_time: float = 0.0
    condition_cache_hits: int = 0
    condition_cache_misses: int = 0
    trigger_chain_depth: int = 0
    
    def update_evaluation_time(self, evaluation_time: float) -> None:
        """Update evaluation time metrics."""
        self.total_evaluations += 1
        self.peak_evaluation_time = max(self.peak_evaluation_time, evaluation_time)
        
        # Update rolling average
        alpha = 0.1
        if self.average_evaluation_time == 0.0:
            self.average_evaluation_time = evaluation_time
        else:
            self.average_evaluation_time = (
                alpha * evaluation_time + (1 - alpha) * self.average_evaluation_time
            )
    
    def get_cache_hit_rate(self) -> float:
        """Get condition cache hit rate."""
        total = self.condition_cache_hits + self.condition_cache_misses
        return self.condition_cache_hits / total if total > 0 else 0.0


class TriggerCondition(ABC):
    """Abstract base class for trigger conditions."""
    
    def __init__(self, condition_id: str):
        """Initialize trigger condition."""
        self.condition_id = condition_id
        self.last_evaluation_tick: Optional[int] = None
        self.last_result: Optional[bool] = None
        self.evaluation_count = 0
    
    @abstractmethod
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: CoordinationEngine,
                timeline: TickTimeline) -> bool:
        """Evaluate condition at given tick."""
        pass
    
    @abstractmethod
    def get_dependencies(self) -> Set[str]:
        """Get animation/resource dependencies."""
        pass
    
    def should_cache_result(self) -> bool:
        """Whether this condition's result should be cached."""
        return True
    
    def get_cache_key(self, tick: int) -> str:
        """Get cache key for this condition at given tick."""
        return f"{self.condition_id}_{tick}"


class AnimationStateCondition(TriggerCondition):
    """Condition based on animation state properties."""
    
    def __init__(self, condition_id: str, animation_id: str, 
                 property_name: str, operator: str, target_value: Any):
        """Initialize animation state condition.
        
        Args:
            condition_id: Unique condition identifier
            animation_id: Target animation ID
            property_name: Animation property to check (opacity, position, etc.)
            operator: Comparison operator (==, !=, <, >, <=, >=, contains)
            target_value: Value to compare against
        """
        super().__init__(condition_id)
        self.animation_id = animation_id
        self.property_name = property_name
        self.operator = operator
        self.target_value = target_value
    
    def evaluate(self, tick: int, engine: TickAnimationEngine,
                coordination_engine: CoordinationEngine,
                timeline: TickTimeline) -> bool:
        """Evaluate animation state condition."""
        self.evaluation_count += 1
        self.last_evaluation_tick = tick
        
        # Get animation state
        frame_state = engine.compute_frame_state(tick)
        if self.animation_id not in frame_state:
            self.last_result = False
            return False
        
        animation_state = frame_state[self.animation_id]
        
        # Get property value
        if hasattr(animation_state, self.property_name):
            current_value = getattr(animation_state, self.property_name)
        elif self.property_name in animation_state.custom_properties:
            current_value = animation_state.custom_properties[self.property_name]
        else:
            self.last_result = False
            return False
        
        # Evaluate condition
        result = self._compare_values(current_value, self.operator, self.target_value)
        self.last_result = result
        return result
    
    def _compare_values(self, current: Any, operator: str, target: Any) -> bool:
        """Compare values using specified operator."""
        try:
            if operator == "==":
                return current == target
            elif operator == "!=":
                return current != target
            elif operator == "<":
                return current < target
            elif operator == ">":
                return current > target
            elif operator == "<=":
                return current <= target
            elif operator == ">=":
                return current >= target
            elif operator == "contains":
                return target in current
            elif operator == "in_range":
                # target should be a tuple (min, max)
                return target[0] <= current <= target[1]
            else:
                return False
        except (TypeError, ValueError):
            return False
    
    def get_dependencies(self) -> Set[str]:
        """Get animation dependencies."""
        return {self.animation_id}


class TimelineStateCondition(TriggerCondition):
    """Condition based on timeline state."""
    
    def __init__(self, condition_id: str, property_name: str, 
                 operator: str, target_value: Any):
        """Initialize timeline state condition.
        
        Args:
            condition_id: Unique condition identifier
            property_name: Timeline property to check
            operator: Comparison operator
            target_value: Value to compare against
        """
        super().__init__(condition_id)
        self.property_name = property_name
        self.operator = operator
        self.target_value = target_value
    
    def evaluate(self, tick: int, engine: TickAnimationEngine,
                coordination_engine: CoordinationEngine,
                timeline: TickTimeline) -> bool:
        """Evaluate timeline state condition."""
        self.evaluation_count += 1
        self.last_evaluation_tick = tick
        
        timeline_state = timeline.get_timeline_state(tick)
        
        if self.property_name not in timeline_state:
            self.last_result = False
            return False
        
        current_value = timeline_state[self.property_name]
        result = self._compare_values(current_value, self.operator, self.target_value)
        self.last_result = result
        return result
    
    def _compare_values(self, current: Any, operator: str, target: Any) -> bool:
        """Compare values using specified operator."""
        try:
            if operator == "==":
                return current == target
            elif operator == "!=":
                return current != target
            elif operator == "<":
                return current < target
            elif operator == ">":
                return current > target
            elif operator == "<=":
                return current <= target
            elif operator == ">=":
                return current >= target
            else:
                return False
        except (TypeError, ValueError):
            return False
    
    def get_dependencies(self) -> Set[str]:
        """Get dependencies (none for timeline conditions)."""
        return set()


class CompositeCondition(TriggerCondition):
    """Condition that combines multiple conditions with logical operators."""
    
    def __init__(self, condition_id: str, conditions: List[TriggerCondition],
                 operator: LogicalOperator):
        """Initialize composite condition.
        
        Args:
            condition_id: Unique condition identifier
            conditions: List of conditions to combine
            operator: Logical operator to use
        """
        super().__init__(condition_id)
        self.conditions = conditions
        self.operator = operator
    
    def evaluate(self, tick: int, engine: TickAnimationEngine,
                coordination_engine: CoordinationEngine,
                timeline: TickTimeline) -> bool:
        """Evaluate composite condition."""
        self.evaluation_count += 1
        self.last_evaluation_tick = tick
        
        if not self.conditions:
            self.last_result = True
            return True
        
        results = []
        for condition in self.conditions:
            result = condition.evaluate(tick, engine, coordination_engine, timeline)
            results.append(result)
        
        # Apply logical operator
        if self.operator == LogicalOperator.AND:
            final_result = all(results)
        elif self.operator == LogicalOperator.OR:
            final_result = any(results)
        elif self.operator == LogicalOperator.NOT:
            # NOT applies to first condition only
            final_result = not results[0] if results else True
        elif self.operator == LogicalOperator.XOR:
            # XOR: exactly one condition should be true
            final_result = sum(results) == 1
        else:
            final_result = False
        
        self.last_result = final_result
        return final_result
    
    def get_dependencies(self) -> Set[str]:
        """Get all dependencies from sub-conditions."""
        dependencies = set()
        for condition in self.conditions:
            dependencies.update(condition.get_dependencies())
        return dependencies


class StateTrigger:
    """State-based trigger with condition evaluation and action execution."""
    
    def __init__(self, trigger_id: str, condition: TriggerCondition,
                 action: Callable[[int, TickAnimationEngine, CoordinationEngine, TickTimeline], None],
                 priority: TriggerPriority = TriggerPriority.NORMAL,
                 auto_reset: bool = False,
                 cooldown_ticks: int = 0):
        """Initialize state trigger.
        
        Args:
            trigger_id: Unique trigger identifier
            condition: Trigger condition
            action: Action to execute when triggered
            priority: Trigger execution priority
            auto_reset: Whether trigger resets after execution
            cooldown_ticks: Minimum ticks between trigger activations
        """
        self.trigger_id = trigger_id
        self.condition = condition
        self.action = action
        self.priority = priority
        self.auto_reset = auto_reset
        self.cooldown_ticks = cooldown_ticks
        
        self.state = TriggerState.INACTIVE
        self.last_triggered_tick: Optional[int] = None
        self.trigger_count = 0
        self.created_at = time.perf_counter()
        
        # Chaining support
        self.chained_triggers: List['StateTrigger'] = []
        self.chain_delay_ticks = 0
    
    def add_chained_trigger(self, trigger: 'StateTrigger', delay_ticks: int = 0) -> None:
        """Add a trigger to execute after this trigger fires."""
        self.chained_triggers.append(trigger)
        self.chain_delay_ticks = delay_ticks
    
    def can_trigger(self, tick: int) -> bool:
        """Check if trigger can fire at given tick."""
        if self.state not in (TriggerState.INACTIVE, TriggerState.ACTIVE):
            return False
        
        # Check cooldown
        if (self.last_triggered_tick is not None and 
            tick - self.last_triggered_tick < self.cooldown_ticks):
            return False
        
        return True
    
    def evaluate(self, tick: int, engine: TickAnimationEngine,
                coordination_engine: CoordinationEngine,
                timeline: TickTimeline) -> List[TriggerEvent]:
        """Evaluate trigger and execute if conditions are met."""
        events = []
        
        if not self.can_trigger(tick):
            return events
        
        # Evaluate condition
        try:
            condition_met = self.condition.evaluate(tick, engine, coordination_engine, timeline)
        except Exception as e:
            # Condition evaluation failed
            self.state = TriggerState.FAILED
            event = TriggerEvent(
                trigger_id=self.trigger_id,
                event_type="trigger_failed",
                tick=tick,
                data={"error": str(e)},
                priority=self.priority
            )
            events.append(event)
            return events
        
        if condition_met:
            # Execute trigger action
            try:
                self.action(tick, engine, coordination_engine, timeline)
                self.last_triggered_tick = tick
                self.trigger_count += 1
                self.state = TriggerState.TRIGGERED
                
                # Create trigger event
                event = TriggerEvent(
                    trigger_id=self.trigger_id,
                    event_type="trigger_activated",
                    tick=tick,
                    data={
                        "condition_id": self.condition.condition_id,
                        "trigger_count": self.trigger_count
                    },
                    priority=self.priority
                )
                events.append(event)
                
                # Execute chained triggers
                for chained_trigger in self.chained_triggers:
                    chain_tick = tick + self.chain_delay_ticks
                    chain_events = chained_trigger.evaluate(chain_tick, engine, coordination_engine, timeline)
                    events.extend(chain_events)
                
                # Handle auto-reset
                if self.auto_reset:
                    self.state = TriggerState.INACTIVE
                else:
                    self.state = TriggerState.COMPLETED
                
            except Exception as e:
                # Action execution failed
                self.state = TriggerState.FAILED
                event = TriggerEvent(
                    trigger_id=self.trigger_id,
                    event_type="trigger_action_failed",
                    tick=tick,
                    data={"error": str(e)},
                    priority=self.priority
                )
                events.append(event)
        
        return events
    
    def reset(self) -> None:
        """Reset trigger to inactive state."""
        self.state = TriggerState.INACTIVE
        self.last_triggered_tick = None
    
    def get_dependencies(self) -> Set[str]:
        """Get all dependencies from condition."""
        return self.condition.get_dependencies()
    
    def get_trigger_info(self) -> Dict[str, Any]:
        """Get detailed trigger information."""
        return {
            "trigger_id": self.trigger_id,
            "condition_id": self.condition.condition_id,
            "state": self.state.value,
            "priority": self.priority.value,
            "auto_reset": self.auto_reset,
            "cooldown_ticks": self.cooldown_ticks,
            "last_triggered_tick": self.last_triggered_tick,
            "trigger_count": self.trigger_count,
            "chained_triggers": len(self.chained_triggers),
            "dependencies": list(self.get_dependencies())
        }


class TriggerConditionCache:
    """Cache for trigger condition evaluation results."""
    
    def __init__(self, max_entries: int = 1000, ttl_ticks: int = 60):
        """Initialize condition cache.
        
        Args:
            max_entries: Maximum cache entries
            ttl_ticks: Time-to-live in ticks
        """
        self.max_entries = max_entries
        self.ttl_ticks = ttl_ticks
        self.cache: Dict[str, Tuple[bool, int]] = {}  # key -> (result, tick)
        self.access_order: deque = deque()
        self.lock = threading.RLock()
    
    def get(self, key: str, current_tick: int) -> Optional[bool]:
        """Get cached condition result if still valid."""
        with self.lock:
            if key in self.cache:
                result, cached_tick = self.cache[key]
                if current_tick - cached_tick <= self.ttl_ticks:
                    # Move to end (most recently used)
                    self.access_order.remove(key)
                    self.access_order.append(key)
                    return result
                else:
                    # Expired, remove from cache
                    del self.cache[key]
                    self.access_order.remove(key)
            return None
    
    def put(self, key: str, result: bool, tick: int) -> None:
        """Cache condition result."""
        with self.lock:
            if key in self.cache:
                # Update existing entry
                self.access_order.remove(key)
            elif len(self.cache) >= self.max_entries:
                # Evict least recently used
                lru_key = self.access_order.popleft()
                del self.cache[lru_key]
            
            self.cache[key] = (result, tick)
            self.access_order.append(key)
    
    def clear(self) -> None:
        """Clear cache."""
        with self.lock:
            self.cache.clear()
            self.access_order.clear()


class StateTriggerSystem:
    """Central system for managing state-based triggers."""
    
    def __init__(self):
        """Initialize trigger system."""
        self.triggers: Dict[str, StateTrigger] = {}
        self.triggers_by_priority: Dict[TriggerPriority, List[StateTrigger]] = defaultdict(list)
        self.condition_cache = TriggerConditionCache()
        self.performance_metrics = TriggerPerformanceMetrics()
        self.event_history: List[TriggerEvent] = []
        self.system_lock = threading.RLock()
    
    def add_trigger(self, trigger: StateTrigger) -> str:
        """Add trigger to system."""
        with self.system_lock:
            self.triggers[trigger.trigger_id] = trigger
            self.triggers_by_priority[trigger.priority].append(trigger)
            trigger.state = TriggerState.ACTIVE
            return trigger.trigger_id
    
    def remove_trigger(self, trigger_id: str) -> bool:
        """Remove trigger from system."""
        with self.system_lock:
            if trigger_id in self.triggers:
                trigger = self.triggers.pop(trigger_id)
                self.triggers_by_priority[trigger.priority].remove(trigger)
                return True
            return False
    
    def evaluate_triggers(self, tick: int, engine: TickAnimationEngine,
                         coordination_engine: CoordinationEngine,
                         timeline: TickTimeline) -> List[TriggerEvent]:
        """Evaluate all triggers in priority order."""
        start_time = time.perf_counter()
        
        with self.system_lock:
            all_events = []
            
            # Evaluate triggers by priority (critical first)
            for priority in TriggerPriority:
                triggers = self.triggers_by_priority[priority]
                for trigger in triggers:
                    try:
                        events = trigger.evaluate(tick, engine, coordination_engine, timeline)
                        all_events.extend(events)
                    except Exception as e:
                        # Create error event
                        error_event = TriggerEvent(
                            trigger_id=trigger.trigger_id,
                            event_type="trigger_system_error",
                            tick=tick,
                            data={"error": str(e)},
                            priority=priority
                        )
                        all_events.append(error_event)
            
            # Record events
            self.event_history.extend(all_events)
            
            # Limit event history
            if len(self.event_history) > 10000:
                self.event_history = self.event_history[-5000:]
            
            # Update performance metrics
            evaluation_time = time.perf_counter() - start_time
            self.performance_metrics.update_evaluation_time(evaluation_time)
            self.performance_metrics.total_triggers += len(all_events)
            
            return all_events
    
    def get_trigger(self, trigger_id: str) -> Optional[StateTrigger]:
        """Get trigger by ID."""
        return self.triggers.get(trigger_id)
    
    def get_active_triggers(self) -> List[StateTrigger]:
        """Get all active triggers."""
        return [t for t in self.triggers.values() if t.state == TriggerState.ACTIVE]
    
    def get_triggered_triggers(self) -> List[StateTrigger]:
        """Get all triggered triggers."""
        return [t for t in self.triggers.values() if t.state == TriggerState.TRIGGERED]
    
    def reset_trigger(self, trigger_id: str) -> bool:
        """Reset specific trigger."""
        trigger = self.triggers.get(trigger_id)
        if trigger:
            trigger.reset()
            return True
        return False
    
    def reset_all_triggers(self) -> int:
        """Reset all triggers."""
        count = 0
        for trigger in self.triggers.values():
            trigger.reset()
            count += 1
        return count
    
    def get_system_state(self) -> Dict[str, Any]:
        """Get comprehensive system state."""
        with self.system_lock:
            active_triggers = self.get_active_triggers()
            triggered_triggers = self.get_triggered_triggers()
            
            return {
                "total_triggers": len(self.triggers),
                "active_triggers": len(active_triggers),
                "triggered_triggers": len(triggered_triggers),
                "triggers_by_priority": {
                    priority.name: len(triggers) 
                    for priority, triggers in self.triggers_by_priority.items()
                },
                "performance_metrics": {
                    "total_evaluations": self.performance_metrics.total_evaluations,
                    "total_triggers": self.performance_metrics.total_triggers,
                    "average_evaluation_time": self.performance_metrics.average_evaluation_time,
                    "peak_evaluation_time": self.performance_metrics.peak_evaluation_time,
                    "cache_hit_rate": self.performance_metrics.get_cache_hit_rate()
                },
                "recent_events": [
                    {
                        "trigger_id": e.trigger_id,
                        "event_type": e.event_type,
                        "tick": e.tick,
                        "priority": e.priority.name,
                        "data": e.data
                    }
                    for e in self.event_history[-50:]  # Last 50 events
                ]
            }
    
    def clear_completed_triggers(self) -> int:
        """Remove all completed triggers."""
        with self.system_lock:
            completed_ids = [
                tid for tid, trigger in self.triggers.items()
                if trigger.state == TriggerState.COMPLETED
            ]
            
            for tid in completed_ids:
                self.remove_trigger(tid)
            
            return len(completed_ids)
    
    def get_performance_metrics(self) -> TriggerPerformanceMetrics:
        """Get current performance metrics."""
        return self.performance_metrics


# Convenience functions for creating common trigger patterns

def create_animation_property_trigger(trigger_id: str, animation_id: str,
                                    property_name: str, operator: str, target_value: Any,
                                    action: Callable,
                                    priority: TriggerPriority = TriggerPriority.NORMAL) -> StateTrigger:
    """Create trigger based on animation property."""
    condition = AnimationStateCondition(
        f"{trigger_id}_condition",
        animation_id,
        property_name,
        operator,
        target_value
    )
    return StateTrigger(trigger_id, condition, action, priority)


def create_timeline_state_trigger(trigger_id: str, property_name: str,
                                 operator: str, target_value: Any,
                                 action: Callable,
                                 priority: TriggerPriority = TriggerPriority.NORMAL) -> StateTrigger:
    """Create trigger based on timeline state."""
    condition = TimelineStateCondition(
        f"{trigger_id}_condition",
        property_name,
        operator,
        target_value
    )
    return StateTrigger(trigger_id, condition, action, priority)


def create_composite_trigger(trigger_id: str, conditions: List[TriggerCondition],
                           operator: LogicalOperator, action: Callable,
                           priority: TriggerPriority = TriggerPriority.NORMAL) -> StateTrigger:
    """Create trigger with composite condition."""
    composite_condition = CompositeCondition(
        f"{trigger_id}_composite",
        conditions,
        operator
    )
    return StateTrigger(trigger_id, composite_condition, action, priority)


def create_trigger_chain(base_trigger: StateTrigger, 
                        chained_triggers: List[Tuple[StateTrigger, int]]) -> StateTrigger:
    """Create a chain of triggers with delays."""
    current_trigger = base_trigger
    
    for trigger, delay in chained_triggers:
        current_trigger.add_chained_trigger(trigger, delay)
        current_trigger = trigger
    
    return base_trigger 