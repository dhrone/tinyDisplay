"""
Advanced Coordination Primitives for Tick-Based Animation System

This module provides sophisticated coordination primitives that enable complex
animation sequences with frame-perfect timing and deterministic execution.
All coordination is based on tick-level precision for multi-core safety.

Key Features:
1. TickAnimationSync: Simultaneous animation start coordination
2. TickAnimationBarrier: Completion-based synchronization
3. TickAnimationSequence: Ordered animation chains
4. TickAnimationTrigger: Condition-based activation
5. CoordinationEngine: Central coordination management
"""

import time
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Callable, Optional, Any, Union, Tuple
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict

from .tick_based import TickAnimationEngine, TickAnimationDefinition, TickAnimationState


class CoordinationEventType(Enum):
    """Types of coordination events."""
    SYNC_TRIGGERED = "sync_triggered"
    BARRIER_RESOLVED = "barrier_resolved"
    SEQUENCE_STARTED = "sequence_started"
    SEQUENCE_COMPLETED = "sequence_completed"
    TRIGGER_ACTIVATED = "trigger_activated"
    TRIGGER_DEACTIVATED = "trigger_deactivated"


class CoordinationState(Enum):
    """States of coordination primitives."""
    PENDING = "pending"
    ACTIVE = "active"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class CoordinationEvent:
    """Event generated by coordination primitives."""
    event_type: CoordinationEventType
    tick: int
    coordination_id: str
    data: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.perf_counter)


class CoordinationCondition(ABC):
    """Abstract base class for coordination conditions."""
    
    @abstractmethod
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> bool:
        """Evaluate condition at given tick."""
        pass
    
    @abstractmethod
    def get_dependencies(self) -> Set[str]:
        """Get animation IDs this condition depends on."""
        pass


class AnimationCompletionCondition(CoordinationCondition):
    """Condition that triggers when specified animations complete."""
    
    def __init__(self, animation_ids: Union[str, List[str]]):
        """Initialize with animation IDs to monitor."""
        if isinstance(animation_ids, str):
            animation_ids = [animation_ids]
        self.animation_ids = set(animation_ids)
    
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> bool:
        """Check if all monitored animations are complete."""
        for animation_id in self.animation_ids:
            animation = engine.get_animation(animation_id)
            if animation and not animation.is_completed_at(tick):
                return False
        return True
    
    def get_dependencies(self) -> Set[str]:
        """Return monitored animation IDs."""
        return self.animation_ids.copy()


class AnimationProgressCondition(CoordinationCondition):
    """Condition that triggers when animation reaches specific progress."""
    
    def __init__(self, animation_id: str, target_progress: float):
        """Initialize with animation ID and target progress (0.0-1.0)."""
        self.animation_id = animation_id
        self.target_progress = max(0.0, min(1.0, target_progress))
    
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> bool:
        """Check if animation has reached target progress."""
        animation = engine.get_animation(self.animation_id)
        if not animation or not animation.is_active_at(tick):
            return False
        
        current_progress = animation.get_local_progress(tick)
        return current_progress >= self.target_progress
    
    def get_dependencies(self) -> Set[str]:
        """Return monitored animation ID."""
        return {self.animation_id}


class TickCondition(CoordinationCondition):
    """Condition that triggers at specific tick."""
    
    def __init__(self, target_tick: int):
        """Initialize with target tick."""
        self.target_tick = target_tick
    
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> bool:
        """Check if current tick has reached target."""
        return tick >= self.target_tick
    
    def get_dependencies(self) -> Set[str]:
        """No animation dependencies."""
        return set()


class CoordinationPrimitive(ABC):
    """Abstract base class for coordination primitives."""
    
    def __init__(self, coordination_id: str):
        """Initialize coordination primitive."""
        self.coordination_id = coordination_id
        self.state = CoordinationState.PENDING
        self.created_tick: Optional[int] = None
        self.activated_tick: Optional[int] = None
        self.completed_tick: Optional[int] = None
        self.events: List[CoordinationEvent] = []
    
    @abstractmethod
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> List[CoordinationEvent]:
        """Evaluate coordination primitive at given tick."""
        pass
    
    @abstractmethod
    def get_dependencies(self) -> Set[str]:
        """Get animation IDs this primitive depends on."""
        pass
    
    def is_active(self) -> bool:
        """Check if primitive is active."""
        return self.state == CoordinationState.ACTIVE
    
    def is_completed(self) -> bool:
        """Check if primitive is completed."""
        return self.state == CoordinationState.COMPLETED
    
    def _create_event(self, event_type: CoordinationEventType, tick: int, 
                     data: Dict[str, Any] = None) -> CoordinationEvent:
        """Create coordination event."""
        event = CoordinationEvent(
            event_type=event_type,
            tick=tick,
            coordination_id=self.coordination_id,
            data=data or {}
        )
        self.events.append(event)
        return event


class TickAnimationSync(CoordinationPrimitive):
    """Synchronization primitive for simultaneous animation start."""
    
    def __init__(self, coordination_id: str, animation_ids: List[str], 
                 trigger_condition: CoordinationCondition):
        """Initialize sync primitive.
        
        Args:
            coordination_id: Unique identifier for this sync
            animation_ids: List of animations to start simultaneously
            trigger_condition: Condition that triggers the sync
        """
        super().__init__(coordination_id)
        self.animation_ids = animation_ids.copy()
        self.trigger_condition = trigger_condition
        self.sync_tick: Optional[int] = None
    
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> List[CoordinationEvent]:
        """Evaluate sync condition and trigger if ready."""
        events = []
        
        if self.state == CoordinationState.PENDING:
            if self.trigger_condition.evaluate(tick, engine, coordination_engine):
                # Trigger sync - start all animations at current tick
                self.sync_tick = tick
                self.activated_tick = tick
                self.state = CoordinationState.ACTIVE
                
                # Start all animations
                for animation_id in self.animation_ids:
                    engine.start_animation_at(animation_id, tick)
                
                # Create sync event
                event = self._create_event(
                    CoordinationEventType.SYNC_TRIGGERED,
                    tick,
                    {
                        'animation_ids': self.animation_ids,
                        'sync_tick': tick
                    }
                )
                events.append(event)
                
                # Mark as completed immediately (sync is instantaneous)
                self.completed_tick = tick
                self.state = CoordinationState.COMPLETED
        
        return events
    
    def get_dependencies(self) -> Set[str]:
        """Get dependencies from trigger condition."""
        deps = self.trigger_condition.get_dependencies()
        deps.update(self.animation_ids)
        return deps


class TickAnimationBarrier(CoordinationPrimitive):
    """Barrier primitive for completion-based synchronization."""
    
    def __init__(self, coordination_id: str, animation_ids: List[str], 
                 on_completion: Optional[Callable[[], None]] = None):
        """Initialize barrier primitive.
        
        Args:
            coordination_id: Unique identifier for this barrier
            animation_ids: List of animations to wait for
            on_completion: Optional callback when barrier resolves
        """
        super().__init__(coordination_id)
        self.animation_ids = animation_ids.copy()
        self.on_completion = on_completion
        self.completion_condition = AnimationCompletionCondition(animation_ids)
    
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> List[CoordinationEvent]:
        """Evaluate barrier and resolve when all animations complete."""
        events = []
        
        if self.state == CoordinationState.PENDING:
            # Check if any animations are active
            any_active = False
            for animation_id in self.animation_ids:
                animation = engine.get_animation(animation_id)
                if animation and animation.is_active_at(tick):
                    any_active = True
                    break
            
            if any_active:
                self.state = CoordinationState.ACTIVE
                self.activated_tick = tick
        
        elif self.state == CoordinationState.ACTIVE:
            # Check if all animations are complete
            if self.completion_condition.evaluate(tick, engine, coordination_engine):
                self.completed_tick = tick
                self.state = CoordinationState.COMPLETED
                
                # Execute completion callback
                if self.on_completion:
                    try:
                        self.on_completion()
                    except Exception as e:
                        print(f"Error in barrier completion callback: {e}")
                
                # Create barrier resolved event
                event = self._create_event(
                    CoordinationEventType.BARRIER_RESOLVED,
                    tick,
                    {
                        'animation_ids': self.animation_ids,
                        'completion_tick': tick
                    }
                )
                events.append(event)
        
        return events
    
    def get_dependencies(self) -> Set[str]:
        """Return monitored animation IDs."""
        return set(self.animation_ids)


class TickAnimationSequence(CoordinationPrimitive):
    """Sequence primitive for ordered animation chains."""
    
    def __init__(self, coordination_id: str, sequence_steps: List[Tuple[str, int]], 
                 start_condition: CoordinationCondition):
        """Initialize sequence primitive.
        
        Args:
            coordination_id: Unique identifier for this sequence
            sequence_steps: List of (animation_id, delay_ticks) tuples
            start_condition: Condition that starts the sequence
        """
        super().__init__(coordination_id)
        self.sequence_steps = sequence_steps.copy()
        self.start_condition = start_condition
        self.sequence_start_tick: Optional[int] = None
        self.current_step = 0
        self.step_states: List[bool] = [False] * len(sequence_steps)  # Track which steps are started
    
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> List[CoordinationEvent]:
        """Evaluate sequence and start animations in order."""
        events = []
        
        if self.state == CoordinationState.PENDING:
            if self.start_condition.evaluate(tick, engine, coordination_engine):
                self.sequence_start_tick = tick
                self.activated_tick = tick
                self.state = CoordinationState.ACTIVE
                
                # Create sequence started event
                event = self._create_event(
                    CoordinationEventType.SEQUENCE_STARTED,
                    tick,
                    {
                        'sequence_steps': self.sequence_steps,
                        'start_tick': tick
                    }
                )
                events.append(event)
                
                # Immediately check if any steps should start at this tick
                # (fall through to ACTIVE state logic)
        
        if self.state == CoordinationState.ACTIVE:
            # Check each step to see if it should start
            for i, (animation_id, delay_ticks) in enumerate(self.sequence_steps):
                if not self.step_states[i]:  # Step not yet started
                    step_start_tick = self.sequence_start_tick + delay_ticks
                    if tick >= step_start_tick:
                        # Start this step
                        engine.start_animation_at(animation_id, step_start_tick)
                        self.step_states[i] = True
            
            # Check if all steps are started and completed
            if all(self.step_states):
                all_complete = True
                for animation_id, _ in self.sequence_steps:
                    animation = engine.get_animation(animation_id)
                    if animation and not animation.is_completed_at(tick):
                        all_complete = False
                        break
                
                if all_complete:
                    self.completed_tick = tick
                    self.state = CoordinationState.COMPLETED
                    
                    # Create sequence completed event
                    event = self._create_event(
                        CoordinationEventType.SEQUENCE_COMPLETED,
                        tick,
                        {
                            'sequence_steps': self.sequence_steps,
                            'completion_tick': tick
                        }
                    )
                    events.append(event)
        
        return events
    
    def get_dependencies(self) -> Set[str]:
        """Get dependencies from start condition and sequence animations."""
        deps = self.start_condition.get_dependencies()
        deps.update(animation_id for animation_id, _ in self.sequence_steps)
        return deps


class TickAnimationTrigger(CoordinationPrimitive):
    """Trigger primitive for condition-based activation."""
    
    def __init__(self, coordination_id: str, trigger_condition: CoordinationCondition, 
                 action: Callable[[int, TickAnimationEngine, 'CoordinationEngine'], None],
                 auto_reset: bool = False):
        """Initialize trigger primitive.
        
        Args:
            coordination_id: Unique identifier for this trigger
            trigger_condition: Condition that activates the trigger
            action: Function to execute when triggered
            auto_reset: Whether trigger resets after activation
        """
        super().__init__(coordination_id)
        self.trigger_condition = trigger_condition
        self.action = action
        self.auto_reset = auto_reset
        self.last_triggered_tick: Optional[int] = None
    
    def evaluate(self, tick: int, engine: TickAnimationEngine, 
                coordination_engine: 'CoordinationEngine') -> List[CoordinationEvent]:
        """Evaluate trigger condition and execute action if triggered."""
        events = []
        
        if self.state in (CoordinationState.PENDING, CoordinationState.ACTIVE):
            condition_met = self.trigger_condition.evaluate(tick, engine, coordination_engine)
            
            if condition_met and (self.last_triggered_tick is None or 
                                self.last_triggered_tick != tick):
                # Trigger activated
                self.last_triggered_tick = tick
                if self.state == CoordinationState.PENDING:
                    self.activated_tick = tick
                    self.state = CoordinationState.ACTIVE
                
                # Execute action
                try:
                    self.action(tick, engine, coordination_engine)
                except Exception as e:
                    print(f"Error in trigger action: {e}")
                
                # Create trigger activated event
                event = self._create_event(
                    CoordinationEventType.TRIGGER_ACTIVATED,
                    tick,
                    {
                        'condition_met': True,
                        'action_executed': True
                    }
                )
                events.append(event)
                
                # Handle auto-reset or completion
                if self.auto_reset:
                    # Reset to pending for next trigger
                    self.state = CoordinationState.PENDING
                else:
                    # Mark as completed
                    self.completed_tick = tick
                    self.state = CoordinationState.COMPLETED
        
        return events
    
    def get_dependencies(self) -> Set[str]:
        """Get dependencies from trigger condition."""
        return self.trigger_condition.get_dependencies()
    
    def reset(self) -> None:
        """Reset trigger to pending state."""
        self.state = CoordinationState.PENDING
        self.last_triggered_tick = None


class CoordinationEngine:
    """Central engine for managing coordination primitives."""
    
    def __init__(self, animation_engine: TickAnimationEngine):
        """Initialize coordination engine."""
        self.animation_engine = animation_engine
        self.primitives: Dict[str, CoordinationPrimitive] = {}
        self.event_history: List[CoordinationEvent] = []
        self.current_tick = 0
    
    def add_primitive(self, primitive: CoordinationPrimitive) -> None:
        """Add coordination primitive to engine."""
        self.primitives[primitive.coordination_id] = primitive
        primitive.created_tick = self.current_tick
    
    def remove_primitive(self, coordination_id: str) -> None:
        """Remove coordination primitive from engine."""
        self.primitives.pop(coordination_id, None)
    
    def get_primitive(self, coordination_id: str) -> Optional[CoordinationPrimitive]:
        """Get coordination primitive by ID."""
        return self.primitives.get(coordination_id)
    
    def evaluate_coordination(self, tick: int) -> List[CoordinationEvent]:
        """Evaluate all coordination primitives at given tick."""
        self.current_tick = tick
        all_events = []
        
        # Evaluate all primitives
        for primitive in self.primitives.values():
            try:
                events = primitive.evaluate(tick, self.animation_engine, self)
                all_events.extend(events)
            except Exception as e:
                print(f"Error evaluating coordination primitive {primitive.coordination_id}: {e}")
        
        # Record events in history
        self.event_history.extend(all_events)
        
        # Limit history size
        if len(self.event_history) > 10000:
            self.event_history = self.event_history[-5000:]
        
        return all_events
    
    def get_active_primitives(self) -> List[CoordinationPrimitive]:
        """Get all active coordination primitives."""
        return [p for p in self.primitives.values() if p.is_active()]
    
    def get_completed_primitives(self) -> List[CoordinationPrimitive]:
        """Get all completed coordination primitives."""
        return [p for p in self.primitives.values() if p.is_completed()]
    
    def get_coordination_state(self, target_tick: int) -> Dict[str, Any]:
        """Get complete coordination state at target tick."""
        return {
            'current_tick': target_tick,
            'primitives': {
                pid: {
                    'type': type(primitive).__name__,
                    'state': primitive.state.value,
                    'created_tick': primitive.created_tick,
                    'activated_tick': primitive.activated_tick,
                    'completed_tick': primitive.completed_tick
                }
                for pid, primitive in self.primitives.items()
            },
            'recent_events': [e for e in self.event_history if e.tick >= target_tick - 60],  # Last second
            'active_count': len(self.get_active_primitives()),
            'completed_count': len(self.get_completed_primitives())
        }
    
    def clear_completed_primitives(self) -> int:
        """Remove all completed primitives and return count removed."""
        completed_ids = [
            pid for pid, primitive in self.primitives.items() 
            if primitive.is_completed()
        ]
        
        for pid in completed_ids:
            del self.primitives[pid]
        
        return len(completed_ids)


# Convenience functions for creating common coordination patterns

def create_sync_on_tick(coordination_id: str, animation_ids: List[str], 
                       trigger_tick: int) -> TickAnimationSync:
    """Create sync that triggers at specific tick."""
    condition = TickCondition(trigger_tick)
    return TickAnimationSync(coordination_id, animation_ids, condition)


def create_sync_on_completion(coordination_id: str, animation_ids: List[str], 
                             trigger_animation_ids: List[str]) -> TickAnimationSync:
    """Create sync that triggers when other animations complete."""
    condition = AnimationCompletionCondition(trigger_animation_ids)
    return TickAnimationSync(coordination_id, animation_ids, condition)


def create_barrier_for_animations(coordination_id: str, 
                                 animation_ids: List[str]) -> TickAnimationBarrier:
    """Create barrier that waits for animations to complete."""
    return TickAnimationBarrier(coordination_id, animation_ids)


def create_sequence_with_delays(coordination_id: str, animation_ids: List[str], 
                               delays: List[int], start_tick: int) -> TickAnimationSequence:
    """Create sequence with specified delays between animations."""
    if len(delays) != len(animation_ids):
        raise ValueError("Number of delays must match number of animations")
    
    sequence_steps = list(zip(animation_ids, delays))
    start_condition = TickCondition(start_tick)
    return TickAnimationSequence(coordination_id, sequence_steps, start_condition)


def create_progress_trigger(coordination_id: str, animation_id: str, 
                           target_progress: float, 
                           action: Callable[[int, TickAnimationEngine, CoordinationEngine], None]) -> TickAnimationTrigger:
    """Create trigger that activates when animation reaches target progress."""
    condition = AnimationProgressCondition(animation_id, target_progress)
    return TickAnimationTrigger(coordination_id, condition, action) 