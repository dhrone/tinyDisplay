#!/usr/bin/env python3
"""
Debug script to analyze positions generated by MarqueeExecutor for MOVE commands.

This script isolates each MOVE command and prints the exact positions generated
to understand why our tests are failing at the pixel level.
"""

import os
import sys
import logging
from pprint import pprint

# Add parent directory to sys.path to allow importing tinyDisplay modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))

from tinyDisplay.dsl.marquee_executor import MarqueeExecutor, Position

# Configure detailed logging
logging.basicConfig(level=logging.DEBUG, 
                    format='[%(name)s] %(levelname)s: %(message)s')
logger = logging.getLogger("PositionDebugger")

def debug_single_move(direction, distance, options=None):
    """Debug a single MOVE command and print all positions generated."""
    program = f"MOVE({direction}, {distance})"
    if options:
        options_str = ", ".join([f"{k}={v}" for k, v in options.items()])
        program += f" {{ {options_str} }};"
    else:
        program += ";"
        
    logger.info(f"Testing program: {program}")
    
    # Execute the program
    executor = MarqueeExecutor(program)
    timeline = executor.execute(
        widget_size=(100, 20),
        container_size=(150, 50),
        starting_position=(0, 0)
    )
    
    # Print detailed position info
    logger.info(f"Generated {len(timeline)} positions:")
    for i, pos in enumerate(timeline):
        logger.info(f"  {i}: {pos}")
    
    # Verify delta
    if len(timeline) > 1:
        first = timeline[0]
        last = timeline[-1]
        delta_x = last.x - first.x
        delta_y = last.y - first.y
        logger.info(f"Delta: ({delta_x}, {delta_y})")
    
    return timeline

def debug_sequential_moves():
    """Debug a sequence of MOVE commands to understand segment boundaries."""
    # Same program as in the failing test
    program = """
    # Move right, then down, then left
    MOVE(RIGHT, 50);
    MOVE(DOWN, 20);
    MOVE(LEFT, 30);
    """
    
    logger.info(f"Testing sequential moves program")
    
    # Execute the program
    executor = MarqueeExecutor(program)
    timeline = executor.execute(
        widget_size=(100, 20),
        container_size=(150, 50),
        starting_position=(0, 0)
    )
    
    # Print a summary of all positions
    logger.info(f"Generated {len(timeline)} positions total")
    
    # Print positions in groups of 10 to see the pattern
    for start in range(0, len(timeline), 10):
        end = min(start + 10, len(timeline))
        positions = timeline[start:end]
        logger.info(f"Positions {start}-{end-1}:")
        for i, pos in enumerate(positions, start):
            logger.info(f"  {i}: {pos}")
    
    # Look for direction changes to identify segments
    logger.info("Detecting segment boundaries:")
    
    segments = []
    current_segment = [timeline[0]]
    
    for i in range(1, len(timeline)):
        prev_pos = timeline[i-1]
        curr_pos = timeline[i]
        
        # Detect direction changes
        if i > 1:
            prev_prev_pos = timeline[i-2]
            
            prev_dx = prev_pos.x - prev_prev_pos.x
            prev_dy = prev_pos.y - prev_prev_pos.y
            
            curr_dx = curr_pos.x - prev_pos.x
            curr_dy = curr_pos.y - prev_pos.y
            
            # Direction change?
            direction_changed = False
            if (prev_dx > 0 and curr_dx <= 0) or (prev_dx < 0 and curr_dx >= 0) or \
               (prev_dy > 0 and curr_dy <= 0) or (prev_dy < 0 and curr_dy >= 0) or \
               (prev_dx != 0 and curr_dx == 0) or (prev_dy != 0 and curr_dy == 0) or \
               (prev_dx == 0 and curr_dx != 0) or (prev_dy == 0 and curr_dy != 0):
                direction_changed = True
                
            if direction_changed:
                # Log the boundary
                logger.info(f"Direction change at position {i-1}: {prev_pos} -> {curr_pos}")
                # End the current segment
                segments.append(current_segment)
                # Start a new segment
                current_segment = [curr_pos]
                continue
        
        # If no direction change, add to current segment
        current_segment.append(curr_pos)
    
    # Add the final segment
    if current_segment:
        segments.append(current_segment)
    
    # Log segment details
    logger.info(f"Found {len(segments)} segments:")
    for i, segment in enumerate(segments):
        logger.info(f"Segment {i+1}:")
        logger.info(f"  Length: {len(segment)}")
        logger.info(f"  Start: {segment[0]}")
        logger.info(f"  End: {segment[-1]}")
        delta_x = segment[-1].x - segment[0].x
        delta_y = segment[-1].y - segment[0].y
        logger.info(f"  Delta: ({delta_x}, {delta_y})")
    
    return timeline, segments

if __name__ == "__main__":
    # Individual MOVE commands
    debug_single_move("RIGHT", 50)
    debug_single_move("DOWN", 20)
    debug_single_move("LEFT", 30)
    
    # Sequential moves
    timeline, segments = debug_sequential_moves()
    
    # Output summary
    print("\nSUMMARY OF FINDINGS:")
    print("====================")
    
    if segments:
        for i, segment in enumerate(segments):
            delta_x = segment[-1].x - segment[0].x
            delta_y = segment[-1].y - segment[0].y
            print(f"Segment {i+1}: Start={segment[0]}, End={segment[-1]}, Delta=({delta_x}, {delta_y})") 