# Story 2.2: Advanced Canvas Composition

## Status: Draft

**Fran's SM Review:** ✅ READY FOR DEVELOPMENT - Comprehensive technical guidance provided  
**Epic:** 2 - Core Widget System  
**Estimated Effort:** 1 day  
**Priority:** High - Essential for complex layout management  
**Prerequisites:** Story 2.1 complete (Core Widget Implementation)

## Story

- As a developer
- I need sophisticated canvas composition capabilities
- so that I can create complex layouts with precise positioning, clipping, and layering management

## Acceptance Criteria (ACs)

1. **AC1:** Canvas coordinate system supports absolute and relative positioning
2. **AC2:** Widget clipping and bounds management prevents overflow rendering
3. **AC3:** Advanced z-order management with layer grouping and manipulation
4. **AC4:** Canvas nesting supports hierarchical layouts and coordinate transformation
5. **AC5:** Layout managers (Absolute, Flow, Grid) provide automatic positioning
6. **AC6:** Canvas viewport and scrolling support for large content areas
7. **AC7:** Performance optimization for complex layouts with many widgets

## Tasks / Subtasks

- [ ] Task 1: Enhance Coordinate System (AC: 1, 4)
  - [ ] Extend `src/tinydisplay/canvas/canvas.py` with coordinate transformation support
  - [ ] Implement absolute positioning with pixel-perfect placement
  - [ ] Add relative positioning with percentage-based coordinates
  - [ ] Create coordinate transformation for nested canvas hierarchies
  - [ ] Implement coordinate space conversion utilities
  - [ ] Add coordinate system validation and bounds checking
  - [ ] Create comprehensive coordinate system test suite

- [ ] Task 2: Implement Advanced Clipping System (AC: 2)
  - [ ] Create `src/tinydisplay/canvas/clipping.py` with clipping algorithms
  - [ ] Implement rectangular clipping with efficient algorithms
  - [ ] Add overflow detection and prevention mechanisms
  - [ ] Create clipping region management for nested canvases
  - [ ] Implement clipping optimization for performance
  - [ ] Add visual debugging tools for clipping regions
  - [ ] Create clipping system test suite

- [ ] Task 3: Enhance Z-order Management (AC: 3)
  - [ ] Extend existing `src/tinydisplay/canvas/layering.py` with advanced features
  - [ ] Implement layer grouping and batch manipulation
  - [ ] Add layer templates and presets for common layouts
  - [ ] Create layer animation support for smooth transitions
  - [ ] Implement layer collision detection and resolution
  - [ ] Add layer performance optimization for large widget counts
  - [ ] Create advanced layering test suite

- [ ] Task 4: Implement Canvas Nesting (AC: 4)
  - [ ] Create `src/tinydisplay/canvas/nesting.py` with hierarchical canvas support
  - [ ] Implement parent-child canvas relationships
  - [ ] Add coordinate transformation between canvas levels
  - [ ] Create event propagation through canvas hierarchy
  - [ ] Implement nested canvas rendering optimization
  - [ ] Add canvas tree traversal and manipulation utilities
  - [ ] Create canvas nesting test suite

- [ ] Task 5: Create Layout Managers (AC: 5)
  - [ ] Create `src/tinydisplay/canvas/layouts.py` with layout manager framework
  - [ ] Implement AbsoluteLayout for precise positioning
  - [ ] Create FlowLayout for automatic widget flow
  - [ ] Implement GridLayout for row/column arrangements
  - [ ] Add layout constraint system for responsive design
  - [ ] Create layout animation and transition support
  - [ ] Implement layout performance optimization
  - [ ] Create layout manager test suite

- [ ] Task 6: Implement Viewport and Scrolling (AC: 6)
  - [ ] Create `src/tinydisplay/canvas/viewport.py` with viewport management
  - [ ] Implement scrollable content areas with smooth scrolling
  - [ ] Add viewport clipping and content virtualization
  - [ ] Create scroll event handling and gesture support
  - [ ] Implement scroll performance optimization for large content
  - [ ] Add viewport debugging and visualization tools
  - [ ] Create viewport and scrolling test suite

- [ ] Task 7: Performance Optimization (AC: 7)
  - [ ] Implement canvas rendering optimization strategies
  - [ ] Add dirty region tracking for minimal re-rendering
  - [ ] Create widget culling for off-screen elements
  - [ ] Implement canvas caching and invalidation strategies
  - [ ] Add performance monitoring and profiling tools
  - [ ] Create performance benchmarking suite
  - [ ] Validate performance targets with complex layouts

## Dev Technical Guidance

### Architecture Foundation

Based on the existing canvas system (`src/tinydisplay/canvas/canvas.py`) and layering system (`src/tinydisplay/canvas/layering.py`), enhance the canvas composition following these patterns:

**Enhanced Canvas Directory Structure:**
```
src/tinydisplay/canvas/
├── __init__.py              # Canvas exports and public API
├── canvas.py                # Base canvas class (existing - enhance)
├── layering.py              # Z-order management (existing - enhance)
├── clipping.py              # Clipping algorithms and management
├── nesting.py               # Hierarchical canvas support
├── layouts.py               # Layout manager framework
├── viewport.py              # Viewport and scrolling support
└── transforms.py            # Coordinate transformation utilities
```

### Coordinate System Enhancement

Leverage and extend the existing Canvas class with advanced coordinate support:

```python
from typing import Union, Tuple, Optional, Protocol
from dataclasses import dataclass
from enum import Enum

class CoordinateMode(Enum):
    """Coordinate system modes."""
    ABSOLUTE = "absolute"      # Pixel coordinates
    RELATIVE = "relative"      # Percentage coordinates (0.0-1.0)
    PARENT_RELATIVE = "parent_relative"  # Relative to parent canvas

@dataclass
class Position:
    """Enhanced position with coordinate mode support."""
    x: Union[int, float]
    y: Union[int, float]
    mode: CoordinateMode = CoordinateMode.ABSOLUTE
    
    def to_absolute(self, canvas_bounds: WidgetBounds) -> Tuple[int, int]:
        """Convert position to absolute coordinates."""
        if self.mode == CoordinateMode.ABSOLUTE:
            return (int(self.x), int(self.y))
        elif self.mode == CoordinateMode.RELATIVE:
            return (
                int(self.x * canvas_bounds.width),
                int(self.y * canvas_bounds.height)
            )
        else:
            raise ValueError(f"Unsupported coordinate mode: {self.mode}")

class CoordinateTransform:
    """Coordinate transformation utilities for nested canvases."""
    
    def __init__(self, parent_bounds: WidgetBounds, child_bounds: WidgetBounds):
        self.parent_bounds = parent_bounds
        self.child_bounds = child_bounds
        
    def parent_to_child(self, x: int, y: int) -> Tuple[int, int]:
        """Transform coordinates from parent to child space."""
        return (
            x - self.child_bounds.x,
            y - self.child_bounds.y
        )
        
    def child_to_parent(self, x: int, y: int) -> Tuple[int, int]:
        """Transform coordinates from child to parent space."""
        return (
            x + self.child_bounds.x,
            y + self.child_bounds.y
        )
```

### Advanced Clipping System

Implement efficient clipping algorithms building on the existing canvas clipping:

```python
from typing import List, Optional, Set
from dataclasses import dataclass

@dataclass
class ClippingRegion:
    """Defines a clipping region with bounds and properties."""
    bounds: WidgetBounds
    enabled: bool = True
    clip_children: bool = True
    
class ClippingManager:
    """Advanced clipping management for canvas composition."""
    
    def __init__(self):
        self._clipping_stack: List[ClippingRegion] = []
        self._active_region: Optional[WidgetBounds] = None
        
    def push_clipping_region(self, region: ClippingRegion) -> None:
        """Push a new clipping region onto the stack."""
        self._clipping_stack.append(region)
        self._update_active_region()
        
    def pop_clipping_region(self) -> Optional[ClippingRegion]:
        """Pop the top clipping region from the stack."""
        if self._clipping_stack:
            region = self._clipping_stack.pop()
            self._update_active_region()
            return region
        return None
        
    def _update_active_region(self) -> None:
        """Update the active clipping region based on stack."""
        if not self._clipping_stack:
            self._active_region = None
            return
            
        # Intersect all enabled clipping regions
        active_bounds = None
        for region in self._clipping_stack:
            if region.enabled:
                if active_bounds is None:
                    active_bounds = region.bounds
                else:
                    active_bounds = active_bounds.intersect(region.bounds)
                    
        self._active_region = active_bounds
        
    def is_widget_visible(self, widget_bounds: WidgetBounds) -> bool:
        """Check if widget is visible within active clipping region."""
        if self._active_region is None:
            return True
        return self._active_region.intersects(widget_bounds)
```

### Layout Manager Framework

Create a flexible layout system for automatic widget positioning:

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional

class LayoutManager(ABC):
    """Abstract base class for layout managers."""
    
    @abstractmethod
    def layout_widgets(self, widgets: List[Widget], canvas_bounds: WidgetBounds) -> None:
        """Layout widgets within the given canvas bounds."""
        pass
        
    @abstractmethod
    def get_preferred_size(self, widgets: List[Widget]) -> Tuple[int, int]:
        """Get preferred size for the given widgets."""
        pass

class AbsoluteLayout(LayoutManager):
    """Layout manager for absolute positioning."""
    
    def layout_widgets(self, widgets: List[Widget], canvas_bounds: WidgetBounds) -> None:
        """Layout widgets using their absolute positions."""
        for widget in widgets:
            # Widgets maintain their absolute positions
            # Validate bounds are within canvas
            if hasattr(widget, 'position'):
                x, y = widget.position
                if not canvas_bounds.contains_point(x, y):
                    # Handle out-of-bounds positioning
                    pass
                    
class FlowLayout(LayoutManager):
    """Layout manager for automatic widget flow."""
    
    def __init__(self, direction: str = "horizontal", spacing: int = 5):
        self.direction = direction
        self.spacing = spacing
        
    def layout_widgets(self, widgets: List[Widget], canvas_bounds: WidgetBounds) -> None:
        """Layout widgets in flow arrangement."""
        current_x, current_y = canvas_bounds.x, canvas_bounds.y
        
        for widget in widgets:
            widget.position = (current_x, current_y)
            
            if self.direction == "horizontal":
                current_x += widget.size[0] + self.spacing
                if current_x + widget.size[0] > canvas_bounds.right:
                    # Wrap to next line
                    current_x = canvas_bounds.x
                    current_y += widget.size[1] + self.spacing
            else:  # vertical
                current_y += widget.size[1] + self.spacing

class GridLayout(LayoutManager):
    """Layout manager for grid arrangements."""
    
    def __init__(self, rows: int, columns: int, spacing: Tuple[int, int] = (5, 5)):
        self.rows = rows
        self.columns = columns
        self.spacing = spacing
        
    def layout_widgets(self, widgets: List[Widget], canvas_bounds: WidgetBounds) -> None:
        """Layout widgets in grid arrangement."""
        cell_width = (canvas_bounds.width - (self.columns - 1) * self.spacing[0]) // self.columns
        cell_height = (canvas_bounds.height - (self.rows - 1) * self.spacing[1]) // self.rows
        
        for i, widget in enumerate(widgets):
            if i >= self.rows * self.columns:
                break  # More widgets than grid cells
                
            row = i // self.columns
            col = i % self.columns
            
            x = canvas_bounds.x + col * (cell_width + self.spacing[0])
            y = canvas_bounds.y + row * (cell_height + self.spacing[1])
            
            widget.position = (x, y)
            widget.size = (cell_width, cell_height)
```

### Canvas Nesting Support

Implement hierarchical canvas relationships:

```python
from typing import Optional, List, Dict

class NestedCanvas(Canvas):
    """Canvas with support for parent-child relationships."""
    
    def __init__(self, config: CanvasConfig, parent: Optional['NestedCanvas'] = None, 
                 canvas_id: Optional[str] = None):
        super().__init__(config, canvas_id)
        self._parent: Optional[NestedCanvas] = parent
        self._children: List[NestedCanvas] = []
        self._coordinate_transform: Optional[CoordinateTransform] = None
        
        if parent:
            parent._add_child_canvas(self)
            
    def _add_child_canvas(self, child: 'NestedCanvas') -> None:
        """Add a child canvas."""
        if child not in self._children:
            self._children.append(child)
            child._parent = self
            child._update_coordinate_transform()
            
    def _remove_child_canvas(self, child: 'NestedCanvas') -> None:
        """Remove a child canvas."""
        if child in self._children:
            self._children.remove(child)
            child._parent = None
            child._coordinate_transform = None
            
    def _update_coordinate_transform(self) -> None:
        """Update coordinate transformation based on parent relationship."""
        if self._parent:
            self._coordinate_transform = CoordinateTransform(
                self._parent.bounds,
                self.bounds
            )
            
    def transform_to_parent(self, x: int, y: int) -> Tuple[int, int]:
        """Transform coordinates to parent space."""
        if self._coordinate_transform:
            return self._coordinate_transform.child_to_parent(x, y)
        return (x, y)
        
    def transform_from_parent(self, x: int, y: int) -> Tuple[int, int]:
        """Transform coordinates from parent space."""
        if self._coordinate_transform:
            return self._coordinate_transform.parent_to_child(x, y)
        return (x, y)
        
    def render(self, target_canvas: Optional['Canvas'] = None) -> None:
        """Render canvas and all child canvases."""
        # Render this canvas
        super().render(target_canvas)
        
        # Render child canvases
        for child in self._children:
            if child.state == CanvasState.ACTIVE:
                child.render(self)
```

### Viewport and Scrolling System

Implement scrollable content areas:

```python
from dataclasses import dataclass
from typing import Tuple, Optional

@dataclass
class ViewportConfig:
    """Configuration for viewport behavior."""
    width: int
    height: int
    content_width: int
    content_height: int
    scroll_x: int = 0
    scroll_y: int = 0
    enable_horizontal_scroll: bool = True
    enable_vertical_scroll: bool = True
    smooth_scrolling: bool = True

class Viewport:
    """Viewport for scrollable content areas."""
    
    def __init__(self, config: ViewportConfig):
        self.config = config
        self._scroll_x = config.scroll_x
        self._scroll_y = config.scroll_y
        self._target_scroll_x = config.scroll_x
        self._target_scroll_y = config.scroll_y
        
    @property
    def visible_bounds(self) -> WidgetBounds:
        """Get the currently visible bounds."""
        return WidgetBounds(
            self._scroll_x,
            self._scroll_y,
            self.config.width,
            self.config.height
        )
        
    def scroll_to(self, x: int, y: int, smooth: bool = None) -> None:
        """Scroll to specific coordinates."""
        if smooth is None:
            smooth = self.config.smooth_scrolling
            
        # Clamp scroll values
        max_scroll_x = max(0, self.config.content_width - self.config.width)
        max_scroll_y = max(0, self.config.content_height - self.config.height)
        
        x = max(0, min(x, max_scroll_x))
        y = max(0, min(y, max_scroll_y))
        
        if smooth:
            self._target_scroll_x = x
            self._target_scroll_y = y
        else:
            self._scroll_x = x
            self._scroll_y = y
            self._target_scroll_x = x
            self._target_scroll_y = y
            
    def update_smooth_scroll(self, delta_time: float) -> bool:
        """Update smooth scrolling animation."""
        if not self.config.smooth_scrolling:
            return False
            
        # Simple linear interpolation for smooth scrolling
        scroll_speed = 500  # pixels per second
        max_delta = scroll_speed * delta_time
        
        changed = False
        
        # Update X scroll
        if abs(self._target_scroll_x - self._scroll_x) > 1:
            delta_x = self._target_scroll_x - self._scroll_x
            delta_x = max(-max_delta, min(max_delta, delta_x))
            self._scroll_x += delta_x
            changed = True
            
        # Update Y scroll
        if abs(self._target_scroll_y - self._scroll_y) > 1:
            delta_y = self._target_scroll_y - self._scroll_y
            delta_y = max(-max_delta, min(max_delta, delta_y))
            self._scroll_y += delta_y
            changed = True
            
        return changed
        
    def is_widget_visible(self, widget_bounds: WidgetBounds) -> bool:
        """Check if widget is visible in viewport."""
        return self.visible_bounds.intersects(widget_bounds)
```

### Performance Optimization Strategies

Implement performance optimizations for complex layouts:

```python
from typing import Set, List, Optional
import time

class CanvasPerformanceManager:
    """Performance optimization for canvas rendering."""
    
    def __init__(self, canvas: Canvas):
        self.canvas = canvas
        self._dirty_regions: Set[WidgetBounds] = set()
        self._culled_widgets: Set[str] = set()
        self._render_cache: Dict[str, Any] = {}
        self._last_cull_time = 0.0
        self._cull_interval = 1.0 / 30.0  # 30fps culling updates
        
    def update_dirty_regions(self, bounds: WidgetBounds) -> None:
        """Add a dirty region for re-rendering."""
        # Merge overlapping dirty regions for efficiency
        merged_bounds = bounds
        regions_to_remove = set()
        
        for existing_bounds in self._dirty_regions:
            if existing_bounds.intersects(bounds):
                merged_bounds = merged_bounds.union(existing_bounds)
                regions_to_remove.add(existing_bounds)
                
        for region in regions_to_remove:
            self._dirty_regions.discard(region)
            
        self._dirty_regions.add(merged_bounds)
        
    def cull_widgets(self, viewport_bounds: Optional[WidgetBounds] = None) -> None:
        """Cull widgets outside viewport for performance."""
        current_time = time.time()
        if current_time - self._last_cull_time < self._cull_interval:
            return
            
        self._last_cull_time = current_time
        
        if viewport_bounds is None:
            viewport_bounds = self.canvas.bounds
            
        self._culled_widgets.clear()
        
        for widget in self.canvas.get_children():
            if not viewport_bounds.intersects(widget.bounds):
                self._culled_widgets.add(widget.widget_id)
                
    def should_render_widget(self, widget: Widget) -> bool:
        """Check if widget should be rendered based on culling."""
        return widget.widget_id not in self._culled_widgets
        
    def get_performance_stats(self) -> Dict[str, Any]:
        """Get performance statistics."""
        return {
            'dirty_regions': len(self._dirty_regions),
            'culled_widgets': len(self._culled_widgets),
            'cache_size': len(self._render_cache),
            'total_widgets': len(self.canvas.get_children())
        }
```

### Integration with Existing Systems

Leverage the existing canvas and layering systems:

```python
# Extend the existing Canvas class
class EnhancedCanvas(Canvas):
    """Enhanced canvas with advanced composition features."""
    
    def __init__(self, config: CanvasConfig, canvas_id: Optional[str] = None):
        super().__init__(config, canvas_id)
        
        # Enhanced composition features
        self._layout_manager: Optional[LayoutManager] = None
        self._clipping_manager = ClippingManager()
        self._viewport: Optional[Viewport] = None
        self._performance_manager = CanvasPerformanceManager(self)
        self._coordinate_mode = CoordinateMode.ABSOLUTE
        
    def set_layout_manager(self, layout_manager: LayoutManager) -> None:
        """Set the layout manager for automatic positioning."""
        self._layout_manager = layout_manager
        self._relayout_widgets()
        
    def _relayout_widgets(self) -> None:
        """Trigger widget relayout using current layout manager."""
        if self._layout_manager:
            widgets = list(self.get_children())
            self._layout_manager.layout_widgets(widgets, self.bounds)
            
    def set_viewport(self, viewport: Viewport) -> None:
        """Set viewport for scrollable content."""
        self._viewport = viewport
        
    def render(self, target_canvas: Optional['Canvas'] = None) -> None:
        """Enhanced render with performance optimizations."""
        if self._viewport:
            # Update smooth scrolling
            self._viewport.update_smooth_scroll(1.0 / self.frame_rate)
            
            # Cull widgets outside viewport
            self._performance_manager.cull_widgets(self._viewport.visible_bounds)
            
        # Call parent render with optimizations
        super().render(target_canvas)
```

### Testing Strategy

Following operational guidelines (`docs/operational-guidelines.md`), implement comprehensive testing:

```python
import pytest
from unittest.mock import Mock, patch
from tinydisplay.canvas.layouts import GridLayout, FlowLayout
from tinydisplay.canvas.viewport import Viewport, ViewportConfig

class TestAdvancedCanvasComposition:
    """Comprehensive test suite for advanced canvas composition."""
    
    def test_coordinate_transformation__nested_canvas__correct_conversion(self):
        """Test coordinate transformation between nested canvases."""
        parent_config = CanvasConfig(width=200, height=200)
        child_config = CanvasConfig(width=100, height=100)
        
        parent_canvas = NestedCanvas(parent_config)
        child_canvas = NestedCanvas(child_config, parent=parent_canvas)
        
        # Test coordinate transformation
        parent_x, parent_y = child_canvas.transform_to_parent(50, 50)
        child_x, child_y = child_canvas.transform_from_parent(parent_x, parent_y)
        
        assert child_x == 50
        assert child_y == 50
        
    def test_layout_manager__grid_layout__correct_positioning(self):
        """Test grid layout manager positions widgets correctly."""
        layout = GridLayout(rows=2, columns=2, spacing=(10, 10))
        
        widgets = [Mock() for _ in range(4)]
        for widget in widgets:
            widget.size = (50, 30)
            
        canvas_bounds = WidgetBounds(0, 0, 120, 80)
        layout.layout_widgets(widgets, canvas_bounds)
        
        # Verify grid positioning
        assert widgets[0].position == (0, 0)    # Top-left
        assert widgets[1].position == (60, 0)   # Top-right
        assert widgets[2].position == (0, 40)   # Bottom-left
        assert widgets[3].position == (60, 40)  # Bottom-right
        
    def test_viewport__scrolling__updates_visible_bounds(self):
        """Test viewport scrolling updates visible bounds correctly."""
        config = ViewportConfig(
            width=100, height=100,
            content_width=200, content_height=200
        )
        viewport = Viewport(config)
        
        # Initial state
        bounds = viewport.visible_bounds
        assert bounds.x == 0 and bounds.y == 0
        
        # Scroll and verify
        viewport.scroll_to(50, 30)
        bounds = viewport.visible_bounds
        assert bounds.x == 50 and bounds.y == 30
        
    @pytest.mark.performance
    def test_performance__complex_layout__meets_targets(self):
        """Test performance with complex layouts meets targets."""
        config = CanvasConfig(width=256, height=256, frame_rate=60.0)
        canvas = EnhancedCanvas(config)
        
        # Add many widgets
        for i in range(50):
            widget = Mock()
            widget.widget_id = f"widget_{i}"
            widget.bounds = WidgetBounds(i * 5, i * 3, 20, 15)
            widget.visible = True
            widget.needs_render.return_value = True
            canvas.add_widget(widget)
            
        # Test rendering performance
        import time
        start = time.perf_counter()
        
        for _ in range(60):  # Simulate 1 second at 60fps
            canvas.render()
            
        duration = time.perf_counter() - start
        
        # Should complete 60 renders in under 1 second
        assert duration < 1.0
        assert duration / 60 < 0.01667  # Each render under 16.67ms
```

### Migration Tool Integration

Leverage the migration tool to validate canvas composition API:

```python
def test_canvas_composition_migration_compatibility():
    """Validate canvas composition API works with migrated legacy code."""
    legacy_layout_config = {
        "type": "grid",
        "rows": 3,
        "columns": 2,
        "spacing": [5, 5],
        "widgets": [
            {"type": "text", "content": "Widget 1"},
            {"type": "text", "content": "Widget 2"}
        ]
    }
    
    # Test migration tool can generate equivalent DSL
    from migration_tool import validate_canvas_api
    migrated_canvas = validate_canvas_api(legacy_layout_config)
    
    assert isinstance(migrated_canvas._layout_manager, GridLayout)
    assert migrated_canvas._layout_manager.rows == 3
    assert migrated_canvas._layout_manager.columns == 2
```

## Story Progress Notes

### Agent Model Used: `Claude Sonnet 4 (Fran - SM)`

### Completion Notes List

- Story created with comprehensive technical guidance based on existing canvas foundation
- All acceptance criteria mapped to specific implementation tasks with detailed subtasks
- Performance requirements clearly defined with measurable targets
- Integration patterns established for existing canvas and layering systems
- Testing strategy aligned with operational guidelines (90% coverage requirement)
- Migration tool integration planned for API validation
- Enhanced coordinate system design for flexible positioning
- Advanced clipping algorithms for efficient rendering
- Layout manager framework for automatic widget positioning
- Viewport system for scrollable content areas

### Change Log

- **May 2025:** Initial story creation with Epic 2 planning
- **Ready for Development:** Prerequisites clear, technical guidance comprehensive 