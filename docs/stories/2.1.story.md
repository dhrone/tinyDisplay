# Story 2.1: Core Widget Implementation

## Status: InProgress

**Jimmy's PO Review:** ✅ READY FOR DEVELOPMENT - Comprehensive technical guidance provided  
**James Development Notes:** Started Epic 2 development - May 2025  
**Epic:** 2 - Core Widget System  
**Estimated Effort:** 1.5 days  
**Priority:** High - Foundation for all subsequent widget functionality  
**Prerequisites:** Epic 1 complete (widget foundation established)

## Story

- As a developer
- I want functional Text, Image, ProgressBar, and Shape widgets with reactive capabilities
- so that I can build sophisticated display applications with automatic data updates

## Acceptance Criteria (ACs)

1. **AC1:** Text widget renders with dynamic content, fonts, colors, and formatting
2. **AC2:** Image widget displays images with caching, scaling, and format support
3. **AC3:** ProgressBar widget shows progress with smooth animations and customizable styling
4. **AC4:** Shape widgets (Rectangle, Circle, Line) render with styling and positioning
5. **AC5:** All widgets support reactive data binding with automatic re-rendering
6. **AC6:** Widget styling system supports colors, borders, backgrounds, and effects
7. **AC7:** Performance targets met: 60fps with 20+ widgets on Pi Zero 2W

## Tasks / Subtasks

- [x] Task 1: Implement Text Widget (AC: 1, 5, 6) ✅ COMPLETE
  - [x] Create `src/tinydisplay/widgets/text.py` with TextWidget class
  - [x] Implement font rendering with caching system
  - [x] Add text formatting (bold, italic, underline, alignment)
  - [x] Integrate reactive data binding for dynamic content
  - [x] Add text styling (color, background, borders)
  - [x] Implement text wrapping and overflow handling
  - [x] Create comprehensive test suite for text widget (46 tests passing)
  
  **Task 1 Completion Summary:**
  - ✅ TextWidget class with full reactive data binding
  - ✅ FontStyle and TextLayout configuration classes
  - ✅ FontCache with LRU eviction for performance
  - ✅ Text wrapping: WORD, CHAR, ELLIPSIS, NONE modes
  - ✅ Text alignment: LEFT, CENTER, RIGHT, JUSTIFY
  - ✅ Performance optimized: <50ms for 100 widget creation
  - ✅ 46 comprehensive tests covering all functionality
  - ✅ Full integration with Epic 1 reactive system
  - ✅ Memory efficient with __slots__ optimization
  - ✅ Thread-safe font caching system

- [x] Task 2: Implement Image Widget (AC: 2, 5, 6) ✅ COMPLETE
  - [x] Create `src/tinydisplay/widgets/image.py` with ImageWidget class
  - [x] Add image format support (PNG, JPEG, BMP) using Pillow
  - [x] Implement image caching system for memory efficiency
  - [x] Add image scaling and aspect ratio preservation
  - [x] Integrate reactive data binding for dynamic image sources
  - [x] Add image styling (borders, effects, opacity)
  - [x] Implement image loading error handling
  - [x] Create comprehensive test suite for image widget (78 tests passing)
  
  **Task 2 Completion Summary:**
  - ✅ ImageWidget class with full reactive data binding
  - ✅ ImageCache with LRU eviction and memory management (50 images, 100MB limit)
  - ✅ Multiple image source support: file paths, bytes, PIL Images, file objects
  - ✅ Five scaling modes: FIT, FILL, STRETCH, NONE, CENTER
  - ✅ ImageStyle with opacity, brightness, contrast, saturation controls
  - ✅ Seven filter effects: BLUR, SHARPEN, SMOOTH, EDGE_ENHANCE, EMBOSS, CONTOUR
  - ✅ Comprehensive error handling and graceful PIL fallback
  - ✅ 78 comprehensive tests covering all functionality
  - ✅ Performance optimized: <100ms for 50 widget creation
  - ✅ Memory efficient with automatic cache eviction
  - ✅ Thread-safe caching system with statistics tracking
  - ✅ Full integration with Epic 1 reactive and widget systems

- [x] Task 3: Implement ProgressBar Widget (AC: 3, 5, 6) ✅ COMPLETE
  - [x] Create `src/tinydisplay/widgets/progress.py` with ProgressBarWidget class
  - [x] Implement progress value handling with validation (0-100%)
  - [x] Add smooth progress animations with easing functions
  - [x] Integrate reactive data binding for dynamic progress values
  - [x] Add customizable styling (colors, borders, fill patterns)
  - [x] Implement horizontal and vertical orientations
  - [x] Add progress text overlay options
  - [x] Create comprehensive test suite for progress widget (77 tests passing)
  
  **Task 3 Completion Summary:**
  - ✅ ProgressBarWidget class with full reactive data binding
  - ✅ ProgressStyle with comprehensive styling options (colors, borders, gradients, pulse effects)
  - ✅ ProgressAnimation with 5 easing functions: LINEAR, EASE_IN, EASE_OUT, EASE_IN_OUT, BOUNCE, ELASTIC
  - ✅ Horizontal and vertical orientations with proper fill direction
  - ✅ Custom progress ranges (not just 0.0-1.0) with automatic normalization
  - ✅ Text overlay positions: CENTER, LEFT, RIGHT, OUTSIDE_LEFT, OUTSIDE_RIGHT, NONE
  - ✅ Custom text support with reactive binding for dynamic text updates
  - ✅ Pulse animation effects with configurable speed and intensity
  - ✅ Gradient fill support with customizable end colors
  - ✅ Shadow effects with offset, blur, and color configuration
  - ✅ Thread-safe animation system with proper locking
  - ✅ Performance optimized: <100ms for 100 widget creation
  - ✅ 77 comprehensive tests covering all functionality including edge cases
  - ✅ Full integration with Epic 1 reactive and widget systems
  - ✅ Memory efficient with __slots__ optimization
  - ✅ Comprehensive validation and error handling

- [ ] Task 4: Implement Shape Widgets (AC: 4, 5, 6)
  - [ ] Create `src/tinydisplay/widgets/shapes.py` with shape widget classes
  - [ ] Implement RectangleWidget with fill and stroke options
  - [ ] Implement CircleWidget with radius and styling
  - [ ] Implement LineWidget with endpoints and stroke styling
  - [ ] Integrate reactive data binding for dynamic shape properties
  - [ ] Add advanced styling (gradients, patterns, shadows)
  - [ ] Implement shape intersection and bounds calculation
  - [ ] Create comprehensive test suite for shape widgets

- [ ] Task 5: Enhance Widget Styling System (AC: 6)
  - [ ] Create `src/tinydisplay/widgets/styling.py` with styling framework
  - [ ] Implement color management with RGB, HSV, and named colors
  - [ ] Add border styling (width, style, color, radius)
  - [ ] Implement background styling (solid, gradient, pattern)
  - [ ] Add visual effects (shadow, glow, blur)
  - [ ] Create style inheritance and cascading system
  - [ ] Implement style validation and error handling
  - [ ] Create styling system test suite

- [ ] Task 6: Performance Optimization and Validation (AC: 7)
  - [ ] Implement widget rendering optimization strategies
  - [ ] Add memory pooling for frequently created widgets
  - [ ] Optimize reactive binding performance for high-frequency updates
  - [ ] Create performance benchmarking suite
  - [ ] Validate 60fps performance with 20+ widgets on Pi Zero 2W
  - [ ] Implement memory usage monitoring and optimization
  - [ ] Create performance regression tests

## Dev Technical Guidance

### Architecture Foundation

Based on the project structure (`docs/project-structure.md`) and Epic 1 foundation, implement widgets following these patterns:

**Core Widget Directory Structure:**
```
src/tinydisplay/widgets/
├── __init__.py              # Widget exports and public API
├── base.py                  # Abstract widget base (from Epic 1)
├── text.py                  # Text widget implementation
├── image.py                 # Image widget implementation
├── progress.py              # Progress bar widget
├── shapes.py                # Shape primitives (Rectangle, Circle, Line)
├── styling.py               # Widget styling framework
└── collections.py           # Collection widgets (Epic 2.4)
```

### Widget Base Class Integration

Leverage the widget foundation from Epic 1 (`src/tinydisplay/widgets/base.py`):

```python
from tinydisplay.widgets.base import Widget, ReactiveValue
from tinydisplay.core.reactive import ReactiveDataManager
from typing import Union, Optional, Tuple, Dict, Any

class TextWidget(Widget):
    """Text widget with reactive data binding and styling support."""
    
    def __init__(
        self,
        text: Union[str, ReactiveValue],
        font_size: int = 12,
        color: Tuple[int, int, int] = (255, 255, 255),
        font_family: str = "default",
        **kwargs
    ) -> None:
        super().__init__(**kwargs)
        
        # Convert string to ReactiveValue if needed
        self._text = self._ensure_reactive(text)
        self._font_size = font_size
        self._color = color
        self._font_family = font_family
        
        # Bind to reactive updates
        self._text.bind(self._on_text_changed)
        
    def _ensure_reactive(self, value: Union[str, ReactiveValue]) -> ReactiveValue:
        """Convert string values to ReactiveValue instances."""
        if isinstance(value, ReactiveValue):
            return value
        return ReactiveValue(value)
        
    def _on_text_changed(self, reactive_value: ReactiveValue) -> None:
        """Handle reactive text updates."""
        self._mark_dirty()
        self._trigger_render()
```

### Performance Requirements

From `docs/operational-guidelines.md`, target these performance metrics:

**Memory Management:**
- Use `__slots__` for widget classes to reduce memory overhead
- Implement widget pooling for frequently created/destroyed widgets
- Cache rendered content when possible (fonts, images, shapes)
- Target <100MB total memory usage for 20+ widget applications

**Rendering Performance:**
- 60fps sustained rendering on Raspberry Pi Zero 2W
- <50ms response time for reactive updates
- Efficient dirty region tracking to minimize re-rendering
- Batch widget updates for optimal performance

**Performance Monitoring Pattern:**
```python
from tinydisplay.utils.profiling import profile_performance

class TextWidget(Widget):
    @profile_performance
    def render(self, canvas: Canvas) -> None:
        """Render text widget with performance monitoring."""
        # Implementation with automatic performance tracking
        pass
```

### Reactive Data Binding Integration

Integrate with the reactive system from Epic 1 (`src/tinydisplay/core/reactive.py`):

**Reactive Binding Pattern:**
```python
from tinydisplay.core.reactive import ReactiveDataManager, ReactiveValue

class ProgressBarWidget(Widget):
    def __init__(self, progress: Union[float, ReactiveValue], **kwargs):
        super().__init__(**kwargs)
        
        # Bind to reactive data source
        self._progress = self._ensure_reactive(progress)
        self._progress.bind(self._on_progress_changed)
        
        # Validate progress value
        self._validate_progress(self._progress.value)
        
    def _on_progress_changed(self, reactive_value: ReactiveValue) -> None:
        """Handle reactive progress updates with validation."""
        new_value = reactive_value.value
        self._validate_progress(new_value)
        self._mark_dirty()
        self._trigger_render()
        
    def _validate_progress(self, value: float) -> None:
        """Validate progress value is between 0.0 and 1.0."""
        if not 0.0 <= value <= 1.0:
            raise ValueError(f"Progress value must be between 0.0 and 1.0, got {value}")
```

### Widget Styling System

Implement comprehensive styling following the operational guidelines:

**Styling Framework Pattern:**
```python
from dataclasses import dataclass
from typing import Optional, Union, Tuple
from enum import Enum

@dataclass
class WidgetStyle:
    """Comprehensive widget styling configuration."""
    
    # Colors
    foreground_color: Tuple[int, int, int] = (255, 255, 255)
    background_color: Optional[Tuple[int, int, int]] = None
    
    # Borders
    border_width: int = 0
    border_color: Tuple[int, int, int] = (128, 128, 128)
    border_radius: int = 0
    
    # Effects
    shadow_offset: Tuple[int, int] = (0, 0)
    shadow_color: Tuple[int, int, int] = (0, 0, 0)
    opacity: float = 1.0

class StyledWidget(Widget):
    """Base class for widgets with styling support."""
    
    def __init__(self, style: Optional[WidgetStyle] = None, **kwargs):
        super().__init__(**kwargs)
        self._style = style or WidgetStyle()
        
    def apply_style(self, canvas: Canvas) -> None:
        """Apply widget styling to canvas before rendering content."""
        if self._style.background_color:
            canvas.fill_rect(self.bounds, self._style.background_color)
            
        if self._style.border_width > 0:
            canvas.draw_rect(
                self.bounds, 
                self._style.border_color, 
                self._style.border_width
            )
```

### Image Widget Implementation

Leverage Pillow for image handling with memory optimization:

**Image Widget Pattern:**
```python
from PIL import Image, ImageDraw
from typing import Union, Optional
import io
import hashlib

class ImageWidget(Widget):
    """Image widget with caching and scaling support."""
    
    # Class-level image cache for memory efficiency
    _image_cache: Dict[str, Image.Image] = {}
    
    def __init__(
        self,
        image_source: Union[str, bytes, Image.Image, ReactiveValue],
        scale_mode: str = "fit",  # "fit", "fill", "stretch", "none"
        **kwargs
    ):
        super().__init__(**kwargs)
        self._image_source = self._ensure_reactive(image_source)
        self._scale_mode = scale_mode
        self._cached_image: Optional[Image.Image] = None
        self._cache_key: Optional[str] = None
        
        self._image_source.bind(self._on_image_changed)
        
    def _load_image(self, source: Union[str, bytes, Image.Image]) -> Image.Image:
        """Load image with caching for memory efficiency."""
        # Generate cache key
        if isinstance(source, str):
            cache_key = f"file:{source}"
        elif isinstance(source, bytes):
            cache_key = f"bytes:{hashlib.md5(source).hexdigest()}"
        else:
            return source  # Already a PIL Image
            
        # Check cache first
        if cache_key in self._image_cache:
            return self._image_cache[cache_key]
            
        # Load and cache image
        if isinstance(source, str):
            image = Image.open(source)
        else:
            image = Image.open(io.BytesIO(source))
            
        self._image_cache[cache_key] = image
        return image
```

### Testing Strategy

Following operational guidelines (`docs/operational-guidelines.md`), implement comprehensive testing:

**Unit Test Pattern:**
```python
import pytest
from unittest.mock import Mock, patch
from tinydisplay.widgets.text import TextWidget
from tinydisplay.core.reactive import ReactiveValue

class TestTextWidget:
    """Comprehensive test suite for TextWidget."""
    
    def test_initialization__with_string__creates_reactive_value(self):
        """Test string input conversion to ReactiveValue."""
        widget = TextWidget("Hello World")
        assert isinstance(widget._text, ReactiveValue)
        assert widget._text.value == "Hello World"
        
    def test_reactive_binding__value_change__triggers_render(self):
        """Test reactive updates trigger re-rendering."""
        reactive_text = ReactiveValue("Initial")
        widget = TextWidget(reactive_text)
        
        # Mock render trigger
        widget._trigger_render = Mock()
        
        # Update reactive value
        reactive_text.value = "Updated"
        
        # Verify render was triggered
        widget._trigger_render.assert_called_once()
        
    @pytest.mark.performance
    def test_render_performance__high_frequency__meets_target(self):
        """Test rendering performance under high frequency updates."""
        widget = TextWidget("Performance Test")
        canvas = Mock()
        
        import time
        start = time.perf_counter()
        
        # Simulate 60fps for 1 second (60 renders)
        for _ in range(60):
            widget.render(canvas)
            
        duration = time.perf_counter() - start
        
        # Should complete 60 renders in under 16.67ms each (60fps)
        assert duration < 1.0  # Total time under 1 second
        assert duration / 60 < 0.01667  # Each render under 16.67ms
```

### Integration with Canvas System

Leverage the canvas system from Epic 1 (`src/tinydisplay/canvas/canvas.py`):

**Canvas Integration Pattern:**
```python
def render(self, canvas: Canvas) -> None:
    """Render widget to canvas with proper integration."""
    # Apply styling first
    self.apply_style(canvas)
    
    # Render widget-specific content
    self._render_content(canvas)
    
    # Mark widget as clean after successful render
    self.mark_clean()
    
def _render_content(self, canvas: Canvas) -> None:
    """Render widget-specific content - implemented by subclasses."""
    raise NotImplementedError("Subclasses must implement _render_content")
```

### Migration Tool Integration

Leverage the migration tool from Epic 1 to validate widget API design:

**Migration Validation Pattern:**
```python
# Use migration tool to test widget API against legacy patterns
from migration_tool import validate_widget_api

def test_widget_api_migration_compatibility():
    """Validate widget API works with migrated legacy code."""
    legacy_config = {
        "type": "text",
        "content": "Hello World",
        "font_size": 16,
        "color": [255, 255, 255]
    }
    
    # Test migration tool can generate equivalent DSL
    migrated_widget = validate_widget_api(legacy_config)
    assert isinstance(migrated_widget, TextWidget)
    assert migrated_widget._text.value == "Hello World"
```

## Story Progress Notes

### Agent Model Used: `Claude Sonnet 4 (Jimmy - PO)`

### Completion Notes List

- Story created with comprehensive technical guidance based on Epic 1 foundation
- All acceptance criteria mapped to specific implementation tasks
- Performance requirements clearly defined with measurable targets
- Integration patterns established for reactive system and canvas
- Testing strategy aligned with operational guidelines (90% coverage requirement)
- Migration tool integration planned for API validation

### Change Log

- **May 2025:** Initial story creation with Epic 2 planning
- **Ready for Development:** All prerequisites met, technical guidance complete 