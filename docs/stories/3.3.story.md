# Story 3.3: Advanced Coordination & Timeline Management

## Status: Draft

**Epic:** 3 - Animation & Coordination System  
**Estimated Effort:** 1.5 days  
**Priority:** High - Enables complex synchronized animation sequences with frame-perfect timing  
**Prerequisites:** Stories 3.1, 3.2 complete (âœ… 3.1, ðŸš§ 3.2), Tick-based system validated (âœ… 28/28 tests passing)

## Story

- As a developer
- I need tick-based coordination primitives and timeline management
- so that I can create complex, synchronized animation sequences with frame-perfect timing

## Acceptance Criteria (ACs)

1. **AC1:** Tick-based coordination primitives (sync, barrier, sequence, trigger) implemented
2. **AC2:** Timeline management system uses tick precision for frame-perfect timing
3. **AC3:** Coordination state can be predicted at future ticks for pre-computation
4. **AC4:** Complex animation sequences execute with deterministic timing
5. **AC5:** State-based animation triggers respond to tick-based conditions
6. **AC6:** Coordination primitives integrate with multi-core frame pre-computation
7. **AC7:** Timeline debugging tools provide tick-level animation inspection

## Tasks / Subtasks

- [ ] **Task 1: Implement Core Coordination Primitives (AC: 1, 4)**
  - [ ] Create `TickAnimationSync` for simultaneous animation start
  - [ ] Implement `TickAnimationBarrier` for completion-based synchronization
  - [ ] Create `TickAnimationSequence` for ordered animation chains
  - [ ] Implement `TickAnimationTrigger` for condition-based activation
  - [ ] Add coordination primitive validation and error handling
  - [ ] Create comprehensive test suite for all primitives

- [ ] **Task 2: Develop Timeline Management System (AC: 2, 3)**
  - [ ] Create `TickTimeline` class with tick-based precision
  - [ ] Implement `CoordinationPlan` for complex sequence orchestration
  - [ ] Add timeline event scheduling and execution
  - [ ] Create future timeline state prediction API
  - [ ] Implement timeline serialization for multi-core compatibility
  - [ ] Add timeline performance monitoring and metrics

- [ ] **Task 3: Build State-Based Trigger System (AC: 5)**
  - [ ] Implement condition evaluation framework for triggers
  - [ ] Create common trigger conditions (progress, completion, time)
  - [ ] Add custom condition support with validation
  - [ ] Implement trigger state management and lifecycle
  - [ ] Create trigger debugging and inspection tools
  - [ ] Add trigger performance optimization

- [ ] **Task 4: Integrate with Multi-Core Pre-Computation (AC: 6)**
  - [ ] Extend coordination primitives for cross-core prediction
  - [ ] Implement coordination state serialization
  - [ ] Add coordination event pre-computation to worker pool
  - [ ] Create coordination cache for future timeline states
  - [ ] Implement coordination synchronization across cores
  - [ ] Add multi-core coordination performance monitoring

- [ ] **Task 5: Create Timeline Debugging and Visualization Tools (AC: 7)**
  - [ ] Implement timeline inspection API for debugging
  - [ ] Create tick-level animation state visualization
  - [ ] Add coordination event logging and analysis
  - [ ] Implement timeline replay and step-through debugging
  - [ ] Create performance profiling for coordination overhead
  - [ ] Add timeline validation and consistency checking

- [ ] **Task 6: Performance Optimization and Integration Testing (AC: 3, 4, 6)**
  - [ ] Optimize coordination primitive evaluation performance
  - [ ] Implement efficient timeline state computation
  - [ ] Create comprehensive integration test suite
  - [ ] Add performance benchmarks for complex sequences
  - [ ] Validate deterministic behavior across all coordination features
  - [ ] Create coordination best practices documentation

## Dev Technical Guidance

### Architecture Foundation

**Tick-Based Coordination Framework:** This story builds upon the proven tick-based animation system (âœ… 28/28 tests passing) and multi-core pre-computation (Story 3.2) to provide sophisticated coordination primitives that enable complex animation sequences with frame-perfect timing and deterministic execution.

**Key Integration Points:**
1. **TickAnimationEngine**: `src/tinydisplay/animation/tick_based.py` - Core engine with coordination integration
2. **Multi-Core System**: `src/tinydisplay/animation/multicore.py` - Worker pool coordination support
3. **Coordination Framework**: `src/tinydisplay/animation/coordination.py` - NEW: Core coordination primitives
4. **Timeline Management**: `src/tinydisplay/animation/timeline.py` - NEW: Timeline orchestration system

### Technical Implementation Details

**Core Coordination Primitives:**
```python
# src/tinydisplay/animation/coordination.py - NEW FILE
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Callable, Optional, Any
from dataclasses import dataclass
from enum import Enum

class CoordinationEventType(Enum):
    SYNC_TRIGGERED = "sync_triggered"
    BARRIER_RESOLVED = "barrier_resolved"
    SEQUENCE_ADVANCED = "sequence_advanced"
    TRIGGER_ACTIVATED = "trigger_activated"

@dataclass
class CoordinationEvent:
    tick: int
    event_type: CoordinationEventType
    primitive_id: str
    data: Dict[str, Any]

class CoordinationPrimitive(ABC):
    """Base class for all coordination primitives."""
    
    def __init__(self, primitive_id: str, target_tick: int):
        self.primitive_id = primitive_id
        self.target_tick = target_tick
        self.is_active = True
        self.evaluation_count = 0
        self.max_evaluations = 10000  # Prevent infinite loops
    
    @abstractmethod
    def evaluate_at(self, current_tick: int, engine: 'TickAnimationEngine') -> Optional[CoordinationEvent]:
        """Evaluate primitive at current tick and return event if triggered."""
        pass
    
    def can_predict_at(self, tick: int) -> bool:
        """Check if primitive state can be predicted at future tick."""
        return True  # Most primitives are predictable
    
    def serialize_state(self) -> Dict[str, Any]:
        """Serialize primitive state for cross-core computation."""
        return {
            'primitive_id': self.primitive_id,
            'target_tick': self.target_tick,
            'is_active': self.is_active,
            'evaluation_count': self.evaluation_count
        }

class TickAnimationSync(CoordinationPrimitive):
    """Synchronize multiple animations to start at the same tick."""
    
    def __init__(self, primitive_id: str, sync_tick: int):
        super().__init__(primitive_id, sync_tick)
        self.animation_ids: List[str] = []
        self.has_triggered = False
    
    def add_animation(self, animation_id: str) -> None:
        """Add animation to synchronization group."""
        if animation_id not in self.animation_ids:
            self.animation_ids.append(animation_id)
    
    def evaluate_at(self, current_tick: int, engine: 'TickAnimationEngine') -> Optional[CoordinationEvent]:
        """Trigger all animations at sync tick."""
        if self.has_triggered or current_tick < self.target_tick:
            return None
        
        if current_tick >= self.target_tick:
            # Start all animations at sync tick
            for animation_id in self.animation_ids:
                engine.start_animation_at(animation_id, self.target_tick)
            
            self.has_triggered = True
            self.is_active = False
            
            return CoordinationEvent(
                tick=current_tick,
                event_type=CoordinationEventType.SYNC_TRIGGERED,
                primitive_id=self.primitive_id,
                data={'animation_ids': self.animation_ids, 'sync_tick': self.target_tick}
            )
        
        return None

class TickAnimationBarrier(CoordinationPrimitive):
    """Wait for multiple animations to complete before proceeding."""
    
    def __init__(self, primitive_id: str, barrier_tick: int):
        super().__init__(primitive_id, barrier_tick)
        self.waiting_animations: Set[str] = set()
        self.completion_actions: List[Callable] = []
        self.has_resolved = False
    
    def add_waiting_animation(self, animation_id: str) -> None:
        """Add animation that must complete before barrier resolves."""
        self.waiting_animations.add(animation_id)
    
    def add_completion_action(self, action: Callable) -> None:
        """Add action to execute when barrier resolves."""
        self.completion_actions.append(action)
    
    def evaluate_at(self, current_tick: int, engine: 'TickAnimationEngine') -> Optional[CoordinationEvent]:
        """Check if all waiting animations are complete."""
        if self.has_resolved or current_tick < self.target_tick:
            return None
        
        # Check if all waiting animations are completed
        all_complete = True
        for animation_id in self.waiting_animations:
            animation = engine.get_animation(animation_id)
            if animation and not animation.is_completed_at(current_tick):
                all_complete = False
                break
        
        if all_complete:
            # Execute completion actions
            for action in self.completion_actions:
                try:
                    action()
                except Exception as e:
                    # Log error but continue
                    pass
            
            self.has_resolved = True
            self.is_active = False
            
            return CoordinationEvent(
                tick=current_tick,
                event_type=CoordinationEventType.BARRIER_RESOLVED,
                primitive_id=self.primitive_id,
                data={'waiting_animations': list(self.waiting_animations)}
            )
        
        return None

class TickAnimationTrigger(CoordinationPrimitive):
    """Trigger animations based on dynamic conditions."""
    
    def __init__(self, primitive_id: str, condition: Callable[[int, 'TickAnimationEngine'], bool]):
        super().__init__(primitive_id, 0)  # No specific target tick
        self.condition = condition
        self.triggered_animations: List[str] = []
        self.has_triggered = False
        self.max_evaluations = 1000  # Prevent infinite condition checking
    
    def add_triggered_animation(self, animation_id: str) -> None:
        """Add animation to trigger when condition is met."""
        if animation_id not in self.triggered_animations:
            self.triggered_animations.append(animation_id)
    
    def evaluate_at(self, current_tick: int, engine: 'TickAnimationEngine') -> Optional[CoordinationEvent]:
        """Evaluate trigger condition and activate animations if met."""
        if self.has_triggered or self.evaluation_count >= self.max_evaluations:
            return None
        
        self.evaluation_count += 1
        
        try:
            if self.condition(current_tick, engine):
                # Trigger all animations
                for animation_id in self.triggered_animations:
                    engine.start_animation_at(animation_id, current_tick)
                
                self.has_triggered = True
                self.is_active = False
                
                return CoordinationEvent(
                    tick=current_tick,
                    event_type=CoordinationEventType.TRIGGER_ACTIVATED,
                    primitive_id=self.primitive_id,
                    data={'triggered_animations': self.triggered_animations}
                )
        except Exception as e:
            # Log condition evaluation error
            pass
        
        return None

class TickAnimationSequence(CoordinationPrimitive):
    """Execute animations in sequence with optional delays."""
    
    def __init__(self, primitive_id: str, start_tick: int):
        super().__init__(primitive_id, start_tick)
        self.sequence_steps: List[Dict[str, Any]] = []
        self.current_step = 0
        self.step_start_tick = None
    
    def add_step(self, animation_id: str, delay_ticks: int = 0) -> None:
        """Add animation step to sequence."""
        self.sequence_steps.append({
            'animation_id': animation_id,
            'delay_ticks': delay_ticks
        })
    
    def evaluate_at(self, current_tick: int, engine: 'TickAnimationEngine') -> Optional[CoordinationEvent]:
        """Execute next step in sequence if ready."""
        if current_tick < self.target_tick or self.current_step >= len(self.sequence_steps):
            return None
        
        # Initialize step timing
        if self.step_start_tick is None:
            self.step_start_tick = current_tick
        
        current_step_data = self.sequence_steps[self.current_step]
        step_ready_tick = self.step_start_tick + current_step_data['delay_ticks']
        
        if current_tick >= step_ready_tick:
            # Start current step animation
            animation_id = current_step_data['animation_id']
            engine.start_animation_at(animation_id, current_tick)
            
            # Advance to next step
            self.current_step += 1
            self.step_start_tick = current_tick
            
            # Check if sequence is complete
            if self.current_step >= len(self.sequence_steps):
                self.is_active = False
            
            return CoordinationEvent(
                tick=current_tick,
                event_type=CoordinationEventType.SEQUENCE_ADVANCED,
                primitive_id=self.primitive_id,
                data={
                    'step': self.current_step - 1,
                    'animation_id': animation_id,
                    'total_steps': len(self.sequence_steps)
                }
            )
        
        return None
```

**Timeline Management System:**
```python
# src/tinydisplay/animation/timeline.py - NEW FILE
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, field
import threading

@dataclass
class CoordinationPlan:
    """Container for coordinated animation sequence."""
    
    plan_id: str
    primitives: List[CoordinationPrimitive] = field(default_factory=list)
    is_active: bool = True
    start_tick: Optional[int] = None
    
    def add_primitive(self, primitive: CoordinationPrimitive) -> None:
        """Add coordination primitive to plan."""
        self.primitives.append(primitive)
    
    def evaluate_at(self, tick: int, engine: 'TickAnimationEngine') -> List[CoordinationEvent]:
        """Evaluate all primitives in plan at current tick."""
        events = []
        for primitive in self.primitives:
            if primitive.is_active:
                event = primitive.evaluate_at(tick, engine)
                if event:
                    events.append(event)
        
        # Check if plan is complete
        if all(not p.is_active for p in self.primitives):
            self.is_active = False
        
        return events
    
    def predict_events_at(self, tick: int, engine: 'TickAnimationEngine') -> List[CoordinationEvent]:
        """Predict coordination events at future tick."""
        # Create temporary copies of primitives for prediction
        predicted_events = []
        for primitive in self.primitives:
            if primitive.is_active and primitive.can_predict_at(tick):
                # Create temporary primitive state for prediction
                temp_primitive = self._create_prediction_primitive(primitive, tick)
                event = temp_primitive.evaluate_at(tick, engine)
                if event:
                    predicted_events.append(event)
        
        return predicted_events
    
    def serialize_state(self) -> Dict[str, Any]:
        """Serialize plan state for cross-core computation."""
        return {
            'plan_id': self.plan_id,
            'primitives': [p.serialize_state() for p in self.primitives],
            'is_active': self.is_active,
            'start_tick': self.start_tick
        }

class TickTimeline:
    """Timeline management system with tick-based precision."""
    
    def __init__(self, fps: int = 60):
        self.fps = fps
        self.coordination_plans: Dict[str, CoordinationPlan] = {}
        self.event_history: List[CoordinationEvent] = []
        self.current_tick = 0
        self.timeline_lock = threading.RLock()
        self.performance_monitor = TimelinePerformanceMonitor()
    
    def add_coordination_plan(self, plan: CoordinationPlan) -> str:
        """Add coordination plan to timeline."""
        with self.timeline_lock:
            self.coordination_plans[plan.plan_id] = plan
            return plan.plan_id
    
    def remove_coordination_plan(self, plan_id: str) -> bool:
        """Remove coordination plan from timeline."""
        with self.timeline_lock:
            if plan_id in self.coordination_plans:
                del self.coordination_plans[plan_id]
                return True
            return False
    
    def evaluate_at_tick(self, tick: int, engine: 'TickAnimationEngine') -> List[CoordinationEvent]:
        """Evaluate all coordination plans at specific tick."""
        with self.timeline_lock:
            self.current_tick = tick
            all_events = []
            
            for plan_id, plan in list(self.coordination_plans.items()):
                if plan.is_active:
                    events = plan.evaluate_at(tick, engine)
                    all_events.extend(events)
                    
                    # Remove completed plans
                    if not plan.is_active:
                        self.coordination_plans.pop(plan_id, None)
            
            # Record events in history
            self.event_history.extend(all_events)
            
            # Limit history size
            if len(self.event_history) > 10000:
                self.event_history = self.event_history[-5000:]
            
            return all_events
    
    def predict_future_events(self, start_tick: int, end_tick: int, engine: 'TickAnimationEngine') -> List[CoordinationEvent]:
        """Predict coordination events in future tick range."""
        future_events = []
        
        with self.timeline_lock:
            for tick in range(start_tick, end_tick + 1):
                for plan in self.coordination_plans.values():
                    if plan.is_active:
                        predicted_events = plan.predict_events_at(tick, engine)
                        future_events.extend(predicted_events)
        
        return future_events
    
    def get_timeline_state(self, tick: Optional[int] = None) -> Dict[str, Any]:
        """Get complete timeline state for debugging/inspection."""
        target_tick = tick if tick is not None else self.current_tick
        
        with self.timeline_lock:
            return {
                'current_tick': target_tick,
                'active_plans': len([p for p in self.coordination_plans.values() if p.is_active]),
                'total_plans': len(self.coordination_plans),
                'recent_events': [e for e in self.event_history if e.tick >= target_tick - 60],  # Last second
                'performance_metrics': self.performance_monitor.get_metrics()
            }
    
    def serialize_timeline_state(self) -> bytes:
        """Serialize timeline state for cross-core computation."""
        import pickle
        import zlib
        
        with self.timeline_lock:
            state_data = {
                'current_tick': self.current_tick,
                'coordination_plans': {pid: plan.serialize_state() for pid, plan in self.coordination_plans.items()},
                'fps': self.fps
            }
            return zlib.compress(pickle.dumps(state_data))
```

**Common Trigger Conditions:**
```python
# src/tinydisplay/animation/triggers.py - NEW FILE
from typing import Callable, Any
from .tick_based import TickAnimationEngine

class TriggerConditions:
    """Common trigger condition factories."""
    
    @staticmethod
    def animation_progress(animation_id: str, progress_threshold: float) -> Callable[[int, TickAnimationEngine], bool]:
        """Trigger when animation reaches specific progress percentage."""
        def condition(tick: int, engine: TickAnimationEngine) -> bool:
            animation = engine.get_animation(animation_id)
            if animation:
                progress = animation.get_local_progress(tick)
                return progress >= progress_threshold
            return False
        return condition
    
    @staticmethod
    def animation_completed(animation_id: str) -> Callable[[int, TickAnimationEngine], bool]:
        """Trigger when animation completes."""
        def condition(tick: int, engine: TickAnimationEngine) -> bool:
            animation = engine.get_animation(animation_id)
            if animation:
                return animation.is_completed_at(tick)
            return False
        return condition
    
    @staticmethod
    def tick_reached(target_tick: int) -> Callable[[int, TickAnimationEngine], bool]:
        """Trigger when specific tick is reached."""
        def condition(tick: int, engine: TickAnimationEngine) -> bool:
            return tick >= target_tick
        return condition
    
    @staticmethod
    def multiple_animations_completed(animation_ids: List[str]) -> Callable[[int, TickAnimationEngine], bool]:
        """Trigger when all specified animations are completed."""
        def condition(tick: int, engine: TickAnimationEngine) -> bool:
            for animation_id in animation_ids:
                animation = engine.get_animation(animation_id)
                if not animation or not animation.is_completed_at(tick):
                    return False
            return True
        return condition
    
    @staticmethod
    def custom_widget_state(widget_id: str, state_check: Callable[[Any], bool]) -> Callable[[int, TickAnimationEngine], bool]:
        """Trigger based on custom widget state condition."""
        def condition(tick: int, engine: TickAnimationEngine) -> bool:
            # This would need integration with widget system
            # Implementation depends on widget state access patterns
            return False  # Placeholder
        return condition
```

**Integration with Multi-Core System:**
```python
# src/tinydisplay/animation/multicore.py - EXTEND EXISTING FILE
class AnimationWorkerPool:
    def __init__(self, num_workers: int = 3, use_processes: bool = True):
        # Existing initialization
        self.timeline = TickTimeline()  # NEW: Timeline integration
        self.coordination_cache = CoordinationCache(max_events=1000)  # NEW
    
    def predict_coordination_events(self, start_tick: int, end_tick: int, engine_state: bytes) -> List[CoordinationEvent]:
        """Predict coordination events for future tick range."""
        # Deserialize engine state
        engine = AnimationStateSerializer.deserialize_engine_state(engine_state)
        
        # Predict coordination events
        return self.timeline.predict_future_events(start_tick, end_tick, engine)
    
    def submit_coordination_computation(self, task: CoordinationComputationTask) -> str:
        """Submit coordination event computation to worker pool."""
        future = self.executor.submit(_compute_coordination_worker, task)
        self.active_tasks[task.task_id] = future
        return task.task_id

@dataclass
class CoordinationComputationTask:
    start_tick: int
    end_tick: int
    engine_state: bytes
    timeline_state: bytes
    task_id: str

def _compute_coordination_worker(task: CoordinationComputationTask) -> List[CoordinationEvent]:
    """Worker function for coordination event computation."""
    # Deserialize states
    engine = AnimationStateSerializer.deserialize_engine_state(task.engine_state)
    timeline = TimelineSerializer.deserialize_timeline_state(task.timeline_state)
    
    # Compute coordination events
    return timeline.predict_future_events(task.start_tick, task.end_tick, engine)
```

### Performance Requirements

**Target Performance (Pi Zero 2W):**
- **Frame-perfect timing** with tick-based precision (Â±0 tick deviation)
- **<1ms coordination overhead** per frame for typical sequences
- **Deterministic execution** across all coordination primitives
- **Memory efficient** coordination state management within Epic 2 limits

**Validation Requirements:**
- Cross-execution determinism for all coordination primitives
- Performance benchmarking with complex animation sequences
- Memory usage monitoring for coordination state
- Timeline debugging and inspection capabilities

### Project Structure Alignment

**New Files Required:**
```
src/tinydisplay/
â”œâ”€â”€ animation/
â”‚   â”œâ”€â”€ coordination.py       # NEW: Core coordination primitives
â”‚   â”œâ”€â”€ timeline.py          # NEW: Timeline management system
â”‚   â”œâ”€â”€ triggers.py          # NEW: Common trigger conditions
â”‚   â””â”€â”€ debugging.py         # NEW: Timeline debugging tools
```

**Modified Files:**
```
src/tinydisplay/
â”œâ”€â”€ animation/
â”‚   â”œâ”€â”€ tick_based.py        # EXTEND: Add coordination integration
â”‚   â””â”€â”€ multicore.py         # EXTEND: Add coordination pre-computation
â””â”€â”€ rendering/
    â””â”€â”€ engine.py            # MODIFY: Integrate timeline evaluation
```

**Test Files Required:**
```
tests/
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ test_coordination_integration.py    # NEW: Coordination integration tests
â”‚   â””â”€â”€ test_timeline_management.py         # NEW: Timeline system tests
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ animation/
â”‚   â”‚   â”œâ”€â”€ test_coordination.py            # NEW: Coordination primitive tests
â”‚   â”‚   â”œâ”€â”€ test_timeline.py               # NEW: Timeline unit tests
â”‚   â”‚   â””â”€â”€ test_triggers.py               # NEW: Trigger condition tests
â”‚   â””â”€â”€ rendering/
â”‚       â””â”€â”€ test_coordination_rendering.py  # NEW: Coordination rendering tests
â””â”€â”€ performance/
    â””â”€â”€ test_coordination_benchmarks.py     # NEW: Coordination performance tests
```

### Key Architecture Documents

**Primary References:**
- **`docs/tick-based-api-design.md`** - Complete API specification with coordination design (1,281 lines)
- **`src/tinydisplay/animation/tick_based.py`** - Proven deterministic foundation (âœ… 28/28 tests)
- **`src/tinydisplay/animation/multicore.py`** - Multi-core framework (Story 3.2)
- **`research/distributed_coordination_investigation_plan.md`** - Multi-core coordination strategy

**Integration Strategy:**
1. **Phase 1**: Core coordination primitives implementation
2. **Phase 2**: Timeline management system development
3. **Phase 3**: State-based trigger system creation
4. **Phase 4**: Multi-core coordination integration
5. **Phase 5**: Debugging tools and performance optimization

## Story Progress Notes

### Agent Model Used: `Fran (Scrum Master)`

### Completion Notes List

{Implementation notes will be added during development}

### Change Log

- **Initial Creation**: Story 3.3 created with comprehensive coordination and timeline management guidance
- **Epic 3 Integration**: Aligned with tick-based deterministic system and multi-core pre-computation capabilities 