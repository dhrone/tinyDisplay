# Story 4.1: Ring Buffer Data Integration

## Status: ðŸš€ READY FOR IMPLEMENTATION - Ring Buffer Data Integration

**Epic:** 4 - Data Layer Integration & Performance Optimization  
**Estimated Effort:** 2 days  
**Priority:** High - Enables real-time data-driven animations with frame-perfect timing  
**Prerequisites:** Epic 3 complete âœ… (Animation & Coordination System with 104/104 tests passing)

**Implementation Ready:** James (Full Stack Developer) - Story 4.1 Ring Buffer Data Integration ðŸš€

## Story

- As a developer
- I need real-time data streams to automatically trigger and control animations
- so that my display responds immediately to changing data conditions with frame-perfect timing

## Acceptance Criteria (ACs)

1. **AC1:** Ring buffer system ingests real-time data streams with <1ms latency
2. **AC2:** Data changes automatically trigger animation updates through reactive binding
3. **AC3:** Animation parameters dynamically adjust based on current data values
4. **AC4:** Data-driven animation triggers integrate with coordination primitives
5. **AC5:** Memory-efficient data buffering maintains <20MB footprint
6. **AC6:** Performance monitoring tracks data ingestion and animation trigger rates
7. **AC7:** Graceful handling of data stream interruptions and reconnections

## Tasks / Subtasks

- [ ] **Task 1: Implement Core Ring Buffer System (AC: 1, 5)** 
  - [ ] Create thread-safe ring buffer with configurable size limits
  - [ ] Implement efficient data ingestion with <1ms latency
  - [ ] Add memory management with automatic cleanup
  - [ ] Create data point timestamping and ordering
  - [ ] Add buffer overflow handling and data loss prevention
  - [ ] Create comprehensive test suite for ring buffer operations

- [ ] **Task 2: Develop Data-Animation Binding System (AC: 2, 3)** 
  - [ ] Create reactive data binding framework
  - [ ] Implement data-to-animation parameter mapping
  - [ ] Add configurable data transformation functions
  - [ ] Create automatic change detection and propagation
  - [ ] Implement debouncing for high-frequency data updates
  - [ ] Create comprehensive test suite for data binding

- [ ] **Task 3: Build Data-Driven Animation Triggers (AC: 4)** 
  - [ ] Integrate data triggers with coordination primitives
  - [ ] Create threshold-based animation activation
  - [ ] Implement complex condition evaluation for triggers
  - [ ] Add trigger priority and execution ordering
  - [ ] Create trigger chaining and cascading effects
  - [ ] Create comprehensive test suite for data triggers

- [ ] **Task 4: Implement Performance Monitoring (AC: 6)** 
  - [ ] Create data ingestion rate monitoring
  - [ ] Add animation trigger frequency tracking
  - [ ] Implement memory usage monitoring for data buffers
  - [ ] Create performance metrics collection and reporting
  - [ ] Add real-time performance dashboard capabilities
  - [ ] Create comprehensive test suite for monitoring

- [ ] **Task 5: Add Resilience and Error Handling (AC: 7)** 
  - [ ] Implement graceful data stream interruption handling
  - [ ] Add automatic reconnection capabilities
  - [ ] Create data validation and sanitization
  - [ ] Implement fallback mechanisms for data loss
  - [ ] Add comprehensive error logging and recovery
  - [ ] Create comprehensive test suite for error scenarios

- [ ] **Task 6: Integration Testing and Optimization** 
  - [ ] Create end-to-end data-to-animation pipeline tests
  - [ ] Validate performance targets on Pi Zero 2W
  - [ ] Optimize memory usage and data processing efficiency
  - [ ] Create comprehensive integration test suite
  - [ ] Add performance benchmarks and validation
  - [ ] Create documentation and usage examples

## Technical Implementation Details

### Architecture Foundation

**Ring Buffer Integration with Epic 3:** This story builds upon the proven tick-based animation system (âœ… 104/104 tests passing) to provide real-time data-driven animation capabilities with frame-perfect timing and deterministic execution.

**Key Integration Points:**
1. **TickAnimationEngine**: `src/tinydisplay/animation/tick_based.py` - Core engine with data integration
2. **Coordination Framework**: `src/tinydisplay/animation/coordination.py` - Data-driven coordination support
3. **Ring Buffer System**: `src/tinydisplay/data/ring_buffer.py` - NEW: High-performance data streaming
4. **Data Binding Framework**: `src/tinydisplay/data/binding.py` - NEW: Reactive data-animation binding

### Core Ring Buffer Implementation

```python
# src/tinydisplay/data/ring_buffer.py - NEW FILE
import threading
import time
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass
from collections import deque
import weakref

@dataclass
class DataPoint:
    """Single data point with timestamp and metadata."""
    timestamp: float
    data: Dict[str, Any]
    sequence_id: int
    source_id: str

class RingBuffer:
    """High-performance thread-safe ring buffer for real-time data streams."""
    
    def __init__(self, max_size: int = 10000, max_memory_mb: int = 20):
        self.max_size = max_size
        self.max_memory_bytes = max_memory_mb * 1024 * 1024
        self.buffer: deque = deque(maxlen=max_size)
        self.lock = threading.RLock()
        self.sequence_counter = 0
        self.total_bytes = 0
        self.listeners: List[Callable[[DataPoint], None]] = []
        self.performance_monitor = RingBufferMonitor()
    
    def add_data_point(self, data: Dict[str, Any], source_id: str = "default") -> bool:
        """Add data point to buffer with automatic memory management."""
        with self.lock:
            # Create data point
            data_point = DataPoint(
                timestamp=time.time(),
                data=data.copy(),
                sequence_id=self.sequence_counter,
                source_id=source_id
            )
            self.sequence_counter += 1
            
            # Estimate memory usage
            estimated_size = self._estimate_data_size(data_point)
            
            # Check memory limits
            if self.total_bytes + estimated_size > self.max_memory_bytes:
                self._cleanup_old_data(estimated_size)
            
            # Add to buffer
            self.buffer.append(data_point)
            self.total_bytes += estimated_size
            
            # Notify listeners
            self._notify_listeners(data_point)
            
            # Update performance metrics
            self.performance_monitor.record_ingestion(estimated_size)
            
            return True
    
    def get_latest(self, count: int = 1) -> List[DataPoint]:
        """Get latest data points from buffer."""
        with self.lock:
            if count == 1:
                return [self.buffer[-1]] if self.buffer else []
            else:
                return list(self.buffer)[-count:] if len(self.buffer) >= count else list(self.buffer)
    
    def get_data_since(self, timestamp: float) -> List[DataPoint]:
        """Get all data points since specified timestamp."""
        with self.lock:
            return [dp for dp in self.buffer if dp.timestamp >= timestamp]
    
    def add_listener(self, callback: Callable[[DataPoint], None]) -> None:
        """Add callback for real-time data notifications."""
        self.listeners.append(callback)
    
    def remove_listener(self, callback: Callable[[DataPoint], None]) -> None:
        """Remove data notification callback."""
        if callback in self.listeners:
            self.listeners.remove(callback)
```

### Data-Animation Binding System

```python
# src/tinydisplay/data/binding.py - NEW FILE
from typing import Dict, Callable, Any, Optional, List
from dataclasses import dataclass
import threading
from .ring_buffer import RingBuffer, DataPoint

@dataclass
class DataBinding:
    """Binding between data stream and animation parameter."""
    data_key: str
    animation_id: str
    parameter_name: str
    mapping_function: Callable[[Any], Any]
    last_value: Optional[Any] = None
    debounce_ms: int = 0
    last_update_time: float = 0.0

@dataclass
class DataTrigger:
    """Data threshold trigger for animation activation."""
    data_key: str
    condition: Callable[[Any], bool]
    trigger_animation: str
    trigger_coordination: Optional[str] = None
    cooldown_ms: int = 100
    last_triggered: float = 0.0

class DataAnimationBinder:
    """Reactive binding system between data streams and animations."""
    
    def __init__(self, ring_buffer: RingBuffer, animation_engine):
        self.ring_buffer = ring_buffer
        self.animation_engine = animation_engine
        self.bindings: Dict[str, List[DataBinding]] = {}
        self.triggers: Dict[str, List[DataTrigger]] = {}
        self.lock = threading.RLock()
        
        # Register as ring buffer listener
        self.ring_buffer.add_listener(self._on_data_received)
    
    def bind_data_to_animation(self, data_key: str, animation_id: str, 
                              parameter_name: str, mapping_function: Callable[[Any], Any],
                              debounce_ms: int = 0) -> None:
        """Bind data stream to animation parameter."""
        with self.lock:
            binding = DataBinding(
                data_key=data_key,
                animation_id=animation_id,
                parameter_name=parameter_name,
                mapping_function=mapping_function,
                debounce_ms=debounce_ms
            )
            
            if data_key not in self.bindings:
                self.bindings[data_key] = []
            self.bindings[data_key].append(binding)
    
    def add_data_trigger(self, data_key: str, condition: Callable[[Any], bool],
                        trigger_animation: str, trigger_coordination: Optional[str] = None,
                        cooldown_ms: int = 100) -> None:
        """Add data threshold trigger for animations."""
        with self.lock:
            trigger = DataTrigger(
                data_key=data_key,
                condition=condition,
                trigger_animation=trigger_animation,
                trigger_coordination=trigger_coordination,
                cooldown_ms=cooldown_ms
            )
            
            if data_key not in self.triggers:
                self.triggers[data_key] = []
            self.triggers[data_key].append(trigger)
    
    def _on_data_received(self, data_point: DataPoint) -> None:
        """Process incoming data point for bindings and triggers."""
        current_time = time.time() * 1000  # Convert to milliseconds
        current_tick = self.animation_engine.get_current_tick()
        
        with self.lock:
            # Process data bindings
            for data_key, value in data_point.data.items():
                if data_key in self.bindings:
                    for binding in self.bindings[data_key]:
                        self._process_binding(binding, value, current_time, current_tick)
                
                if data_key in self.triggers:
                    for trigger in self.triggers[data_key]:
                        self._process_trigger(trigger, value, current_time, current_tick)
    
    def _process_binding(self, binding: DataBinding, value: Any, 
                        current_time: float, current_tick: int) -> None:
        """Process individual data binding."""
        # Check debounce
        if current_time - binding.last_update_time < binding.debounce_ms:
            return
        
        # Apply mapping function
        try:
            mapped_value = binding.mapping_function(value)
            
            # Check if value changed
            if mapped_value != binding.last_value:
                # Update animation parameter
                self.animation_engine.update_animation_parameter(
                    binding.animation_id,
                    binding.parameter_name,
                    mapped_value,
                    current_tick
                )
                
                binding.last_value = mapped_value
                binding.last_update_time = current_time
                
        except Exception as e:
            # Log mapping function error
            pass
    
    def _process_trigger(self, trigger: DataTrigger, value: Any,
                        current_time: float, current_tick: int) -> None:
        """Process individual data trigger."""
        # Check cooldown
        if current_time - trigger.last_triggered < trigger.cooldown_ms:
            return
        
        # Evaluate trigger condition
        try:
            if trigger.condition(value):
                # Trigger animation
                self.animation_engine.start_animation_at(
                    trigger.trigger_animation, current_tick
                )
                
                # Trigger coordination if specified
                if trigger.trigger_coordination:
                    coordination = self.animation_engine.get_coordination_primitive(
                        trigger.trigger_coordination
                    )
                    if coordination:
                        coordination.trigger_at(current_tick)
                
                trigger.last_triggered = current_time
                
        except Exception as e:
            # Log condition evaluation error
            pass
```

### Integration with Epic 3 Coordination System

```python
# src/tinydisplay/animation/tick_based.py - EXTEND EXISTING FILE
class TickAnimationEngine:
    def __init__(self, fps: int = 60):
        # Existing initialization
        self.data_binder: Optional[DataAnimationBinder] = None  # NEW
    
    def set_data_binder(self, data_binder: DataAnimationBinder) -> None:
        """Set data binding system for reactive updates."""
        self.data_binder = data_binder
    
    def update_animation_parameter(self, animation_id: str, parameter_name: str,
                                  value: Any, current_tick: int) -> bool:
        """Update animation parameter from data binding."""
        animation = self.get_animation(animation_id)
        if animation and hasattr(animation, 'update_parameter'):
            return animation.update_parameter(parameter_name, value, current_tick)
        return False
```

### Performance Monitoring

```python
# src/tinydisplay/data/monitoring.py - NEW FILE
import time
import threading
from typing import Dict, List
from dataclasses import dataclass, field

@dataclass
class PerformanceMetrics:
    """Performance metrics for data layer."""
    ingestion_rate: float = 0.0  # Data points per second
    processing_latency: float = 0.0  # Average processing time in ms
    memory_usage: int = 0  # Current memory usage in bytes
    trigger_rate: float = 0.0  # Animation triggers per second
    binding_updates: int = 0  # Total binding updates
    error_count: int = 0  # Total errors encountered

class DataLayerMonitor:
    """Performance monitoring for data layer components."""
    
    def __init__(self, window_size: int = 60):
        self.window_size = window_size
        self.metrics = PerformanceMetrics()
        self.ingestion_times: List[float] = []
        self.processing_times: List[float] = []
        self.trigger_times: List[float] = []
        self.lock = threading.RLock()
    
    def record_ingestion(self, data_size: int) -> None:
        """Record data ingestion event."""
        with self.lock:
            current_time = time.time()
            self.ingestion_times.append(current_time)
            
            # Cleanup old entries
            cutoff_time = current_time - self.window_size
            self.ingestion_times = [t for t in self.ingestion_times if t > cutoff_time]
            
            # Update rate
            self.metrics.ingestion_rate = len(self.ingestion_times) / self.window_size
    
    def record_processing_time(self, processing_time_ms: float) -> None:
        """Record data processing time."""
        with self.lock:
            self.processing_times.append(processing_time_ms)
            
            # Keep only recent measurements
            if len(self.processing_times) > 1000:
                self.processing_times = self.processing_times[-500:]
            
            # Update average
            if self.processing_times:
                self.metrics.processing_latency = sum(self.processing_times) / len(self.processing_times)
    
    def get_metrics(self) -> PerformanceMetrics:
        """Get current performance metrics."""
        with self.lock:
            return self.metrics
```

## Project Structure Updates

**New Files Required:**
```
src/tinydisplay/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ __init__.py              # EXTEND: Add ring buffer exports
â”‚   â”œâ”€â”€ ring_buffer.py           # NEW: Core ring buffer implementation
â”‚   â”œâ”€â”€ binding.py               # NEW: Data-animation binding system
â”‚   â”œâ”€â”€ monitoring.py            # NEW: Performance monitoring
â”‚   â””â”€â”€ triggers.py              # NEW: Data trigger conditions
```

**Modified Files:**
```
src/tinydisplay/
â”œâ”€â”€ animation/
â”‚   â”œâ”€â”€ tick_based.py            # EXTEND: Add data binding integration
â”‚   â””â”€â”€ coordination.py          # EXTEND: Add data-driven coordination
```

**Test Files Required:**
```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ test_ring_buffer.py          # NEW: Ring buffer unit tests
â”‚   â”‚   â”œâ”€â”€ test_binding.py              # NEW: Data binding tests
â”‚   â”‚   â”œâ”€â”€ test_monitoring.py           # NEW: Monitoring tests
â”‚   â”‚   â””â”€â”€ test_triggers.py             # NEW: Data trigger tests
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ test_data_animation_integration.py  # NEW: End-to-end integration
â”‚   â””â”€â”€ test_performance_targets.py         # NEW: Performance validation
â””â”€â”€ performance/
    â””â”€â”€ test_data_layer_benchmarks.py       # NEW: Performance benchmarks
```

## Definition of Done

- [ ] Ring buffer integrates with animation engine for real-time data ingestion
- [ ] Data changes automatically trigger animation updates through reactive binding
- [ ] Animation parameters dynamically adjust based on current data values
- [ ] Data-driven triggers work with coordination primitives
- [ ] Memory usage remains <20MB for data buffering
- [ ] Performance monitoring tracks data and animation rates
- [ ] Graceful handling of data stream interruptions
- [ ] Comprehensive test suite with >90% coverage
- [ ] Performance benchmarks validate <1ms latency targets
- [ ] Documentation and examples for data-driven animations

## Story Progress Notes

### Agent Model Used: `James (Full Stack Developer)`

### Completion Notes List

{Implementation notes will be added during development}

### Change Log

- **Initial Creation**: Story 4.1 created with comprehensive ring buffer and data binding implementation plan
- **Epic 3 Integration**: Aligned with proven tick-based animation system and coordination primitives 